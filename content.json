{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"effective-C++(2)","slug":"effective-C-2","date":"2019-02-25T06:29:22.000Z","updated":"2019-02-25T08:47:07.218Z","comments":true,"path":"2019/02/25/effective-C-2/","link":"","permalink":"http://yoursite.com/2019/02/25/effective-C-2/","excerpt":"","text":"条款05：了解C++默默编写并调用哪些函数一个完整的C++类，必然包含了构造函数，析构函数，copy构造函数，copy assignment操作符函数，如果没有写这些函数，那么编译器将会生成default版本的函数，大致来说，隐患主要来源于copy构造函数，copy assignment操作符函数过于暴力。默认版本的这两个函数都会直接将rhs的值粗暴地用等号赋值起来，那么对于const的成员，显然会直接报错，另外，对于引用值来说，也是一个很难发现的隐患，因为引用是不可以修改的，如下面的代码 12345string a = \"10\", b = \"1\";string &amp;c = a;cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;\" \"&lt;&lt;c&lt;&lt;endl;c = b;cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;\" \"&lt;&lt;c&lt;&lt;endl; 看意思似乎是将c更改为b的引用，然而实际上只会修改a的值为b，最终使得c仍为a的引用，然而a的值却改变成了b的值。在这简短的代码中，或许比较容易发现，然而在一段较复杂的类代码中，往往是个不容易发现的隐患。 解决这些隐患的方法有两个，第一个是养成自己书写这些会默认生成的函数的习惯，毕竟在简单的类中，实现这些代码并不费多少功夫，而在大的类当中，自然是必不可少的一环，减少bug的隐患。另外一个则是不需要这些函数的时候，将这些函数声明成private，并且只声明不实现，声明为private可以防止用户错误地使用这些有隐患的函数，只声明不实现能防止继承类中使用到这些不需要的函数。 条款06：若不想使用编译器自动生成的函数，就该明确拒绝正如上面所说，编译器为类自动生成的函数有不小的风险，当不需要的时候需要明确地拒绝编译器默认生成，阻止用户使用。在这个过程中，细节有两个，一个是只声明不实现，报错实际上是由编译器报错，而声明为private则是可以在连接器中报错，阻止member函数或friend函数对其进行使用。 而要把连接期的错误移到编译期报错是可以实现的（提早报错是好事），只需要实现一个不可复制的基类即可。 123456789101112131415class Uncopyable &#123;private: Uncopyable(Uncopyable&amp;); Uncopyable&amp; operator=(Uncopyable&amp;);public: Uncopyable() &#123; &#125; ~Uncopyable() &#123; &#125; &#125;;class Customer: private Uncopyable &#123;private: int id;public: Customer(int x): id(x) &#123;&#125;&#125;; 此处有几个可以注意一下的点。 Uncopyable的大小。尽管Uncopyable没有任何成员，sizeof(Uncopyable)仍然为1，因为class和struct的大小都应该大于零。实际上也有一种方法能够实现大小为0的类，就是添加一个大小为0的数组成员，如char s[0]，印象中方法是来自于陈硕的那本muduo。（晚点将该处的解释补上来） 尽管Uncopyable的大小为1，但是其派生类的大小会被编译器优化，如上述代码中Customer的大小就被优化成4了，即一个int的大小。 多重继承下，有些编译器不一定会把Uncopyable的大小优化到最优，但是往往会报warning：direct base ‘Uncopyable’ inaccessible in ‘XXX’ due to ambiguity。 Uncopyable的析构函数作为基类，不需要为virtual的原因是，它并不是作为多态基类的。（加了virtual函数的类的大小以后再深入讨论。） 条款07：为多态基类声明virtual析构函数因为使用多态的时候，需要类真正找到自己合适的析构方法，析构中正确地释放内存，防止内存泄漏或是触碰到不该碰的内存中，所以需要virtual的析构函数，通过virtual指针找到对应的析构函数（跟多态中的其他函数类似）。 而对于本来就不打算作为多态的base class，那么就不应该声明其析构函数为virtual，徒增占用空间。 条款08：别让异常逃离析构函数对于类来说，如果析构的过程中容易抛出异常，这时候就只有两种处理方法，一种是“吞掉异常”，不处理，往往会导致内存泄漏，一种则是“终止进程”，这往往是处理这种异常可取的方法。 然而，无论哪一种方法，都给程序带来了不小的风险，更合适的做法是用户在析构函数外，就将有异常风险的部分处理好，不要试图等到析构过程中出现异常再来处理。 条款09：绝不在构造和析构过程中调用virtual函数当了解了C++类的内存分布，以及构造过程之后就会了解比较深。主要原因就是virtual函数的调用是需要指针指向位置的，在无论是构造过程还是析构过程，都不能完全保证在调用之前，正确的函数指针已经构造完毕或是尚未析构，因此调用将会带来巨大的隐患。 条款10：令operator=返回一个reference to *this可以参考以下的两段代码： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class A &#123;public: A() &#123; cout&lt;&lt;\"Construct\"&lt;&lt;endl; &#125; A(const A&amp; rhs) &#123; cout&lt;&lt;\"Copy Construct\"&lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;\"Deconstruct\"&lt;&lt;endl; &#125; A operator=(const A&amp; rhs) &#123; return *this; &#125;&#125;;int main () &#123; A a, b, c; a = b = c; return 0;&#125; 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class A &#123;public: A() &#123; cout&lt;&lt;\"Construct\"&lt;&lt;endl; &#125; A(const A&amp; rhs) &#123; cout&lt;&lt;\"Copy Construct\"&lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;\"Deconstruct\"&lt;&lt;endl; &#125; A&amp; operator=(const A&amp; rhs) &#123; return *this; &#125;&#125;;int main () &#123; A a, b, c; a = b = c; return 0;&#125; 计算构造函数，拷贝构造函数，析构函数的使用次数，即可知道返回reference to *this会造成的资源浪费了。 条款11：在operator=中处理“自我赋值”先看一种很危险的赋值方法： 12345Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125; 考虑一下如果是自我赋值的话，那么这段代码会将自己给删除了，然后重新赋值，导致指针指向了一个被删除的对象。 再看一种比较危险的处理方法： 1234567Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; if (this == &amp;rhs) return *this; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125; 因为此处先删除了pb，再new bitmap，如果new的过程中因为内存不足等原因出现了异常，那么pb仍然指向了一个被删除的空间，看似安全，实际上没有避免掉本质问题，并非异常安全的。 接下来看安全的下实现版本： 123456Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; Bitmap* pOrig = pb; pb = new Bitmap(*rhs.pb); delete pOrig; return *this;&#125; 显然，这个版本直接处理了不安全的部分，是一种行得通的方法，只是效率并不高。 接下来是比较高效的实现方法，使用了copy and swap技术（异常安全技术）。 12345Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; Widget temp(rhs); swap(rhs); return *this;&#125; 这种技术首先制作了一份副本，然后跟原数据进行了交换，保证了自我赋值正确的同时，确保了异常安全。 更进一步还有这种实现方法： 1234Widget&amp; Widget::operator=(Widget rhs) &#123; swap(rhs); return *this;&#125; 实际上只是把制作副本的过程放到了参数构造中，让编译器可以生成更加高效的代码。 条款12：复制对象时勿忘其每一个成分复制对象的时候不仅要将本类的成员完成好拷贝，对于基类的成员也要保证拷贝完全，实现方法很简单，就是调用其基类的赋值函数。 123456789PriorityCustomer::PriorityCustomer(const PriorityCustomer &amp;rhs): Customer(rhs), priority(rhs.priority) &#123; &#125;PriorityCustomer&amp; PriorityCustomer::operator=(const PriorityCustomer &amp;rhs) &#123; Customer::operator=(rhs); priority = rhs.priority; return *this;&#125;","categories":[],"tags":[]},{"title":"effective c++(1)","slug":"effective-c-1","date":"2019-02-22T02:13:28.000Z","updated":"2019-02-22T07:53:39.534Z","comments":true,"path":"2019/02/22/effective-c-1/","link":"","permalink":"http://yoursite.com/2019/02/22/effective-c-1/","excerpt":"","text":"条款01： 视C++为一个语言联邦简单来说，就是四个次语言，C，object-oriented C++，template C++， stl。 实际上，入门C++很多年了，而且也不是第一次看effective c++了，现在借此博客来重新阅读学习一遍，并做一些总结。 条款02：尽量以const，enum，inline替换#define不使用#define的原因，主要可以用“宁可以编译器替换预处理器”来解释，就是说，#define的内容可能被预处理器直接替代，编译器并无法看到实际编程使用的记号，那么报错的时候将直接使用替代的元素，代码可读性可能没什么区别，但是编译报错之后可能很难定位bug的位置，毕竟当代码量变大的时候，很难回想起一个替换值的意义是什么，因此必要的时候，对于数值等内容可以使用const和enum来替代。 另外，使用#define来定义一些简短的函数，如#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))，当变得复杂，涉及到CALL_WITH_MAX(++a, b)的时候，几乎无法确定(a)被执行了多少次也影响了最终的结果，不加括号的话甚至有可能影响代码的执行顺序，当然这样的代码写法实属取不得，但是也暴露了 #define写法在替代过程中的危险性。要保留简短和高效性，不如使用inline函数。 同时，#define也拥有全局的特性，一旦定义，除非#undef，否则它将一直存在。如果想要具有局部性，有特定的使用区域，那么有两种方法： 使用static const。注意的是，如果需要取该变量的特定地址，就需要在实现文件（语法上可以在头文件，但是推荐是在实现文件）中定义声明一遍。（还有一种需要的可能是编译器（不正确地）需要。），如 12345678910// GamePlayer.hppclass GamePlayer &#123;private: static const int NumTurns = 5; int scores[NumTurns];&#125;;// Gameplayer.cppconst int GamePlayer::NumTurns = 5; 使用enum hack，这种方法更接近于#define，同时也有特定的指定范围，但是它并不能像const那样取得常量的地址，而相当于#define的记号，并不分配内存，而且编译错误中的报错并不像#define那样模糊。缺点在于enum必须是整型常数，对于浮点数或者是其他还是得老老实实使用const，应当注意到enum hack也是模板元编程中会使用的常用技巧之一，以后会说到。 123456789// GamePlayer.hppclass GamePlayer &#123;private: enum &#123; NumTurns = 5, another &#125;; int scores[NumTurns];&#125;; 条款03：尽可能使用const先来区分一下const老题目 12345char greeting[] = \"hello\";const char *p1 = greeting; // 非常量指针，常量数据，数据不可更改char* const p2 = greeting; // 常量指针，非常量数据，指针指向不可更改char const *p3 = greeting; // 非常量指针，常量数据，数据不可更改const char* const p4 = greeting; //常量指针，常量数据，都不可更改 现在首先讲到const返回对象，这个主要是防止使用函数的过程中出现误操作。如 123456789class Rational &#123;...&#125;;const Rational operator* (const Rational &amp;lhs, const Rational &amp;rhs);...Rational a, b, c;if (a * b = c) &#123; ...&#125; 上述例子中本来用来判断的==，写成了赋值，如果不是const类型，那么仍然能够通过编译，因为返回的是一个左值（如果返回int这些基本类型的，作为右值的，那么将会报错），而使用了const之后，因为是一个常量，赋值则会报错，进而避免了这种低级错误。而实际使用方面，如果需要赋值，尽管返回的是const，因为copy assignment函数的存在，因此并不会被影响，当然使用auto的话则需要注意一下了。（auto在此处也不应该这样贸然使用吧。） 接着是const成员函数，如下面的代码 12345678910111213141516171819202122232425262728293031class Text &#123;private: static const int another_size = 15; enum &#123; size = 10, another &#125;; char info[size];public: Text(const char p[]) &#123; int i=0; while (p[i] &amp;&amp; i &lt; size) &#123; info[i] = p[i]; i++; &#125; cout&lt;&lt;another_size&lt;&lt;endl; &#125; Text(const Text &amp;rhs) &#123; for (int i=0;i&lt;size;++i) &#123; info[i] = rhs.info[i]; &#125; &#125; const char &amp;operator[](int idx) const &#123; cout&lt;&lt;\"Const char operator\"&lt;&lt;endl; return info[idx]; &#125; char &amp;operator[](int idx) &#123; cout&lt;&lt;\"char operator\"&lt;&lt;endl; return info[idx]; &#125;&#125;; 对于operator[]函数，要实现两个版本的原因有两个，一个是对于const对象来说，如果没有const函数，那么将无法使用operator[]函数，因为可能涉及到修改，而若单纯有const operator[]自然也是无法修改内容的。而如果没有明确表明是const的话，编译器一般会选择operator[]版本的。 而在声明函数内为const，不会修改成员变量的时候，实在有一些成员需要修改，那么可以使用mutable关键字（不过感觉怪怪的）。、 另外，如果const和非const版本的函数，内容几乎一致，但是为了const对象的使用，那么只能重新实现，但是为了减少代码的重用，可以使用下面的措施。 1234567891011121314class TextBlock &#123;public: const char &amp;operator[](int idx) const &#123; // ... // ... cout&lt;&lt;\"Const char operator\"&lt;&lt;endl; return info[idx]; &#125; char &amp;operator[](int idx) &#123; cout&lt;&lt;\"char operator\"&lt;&lt;endl; return const_cast&lt;char&amp;&gt;( static_cast&lt;const TextBlock&amp;&gt; (*this)[idx]); &#125;&#125;; 应当注意，上面的代码中第一个const_cast是为了去除const属性，使得返回出char&amp;，而第二个static_cast是为了构造出const TextBlock&amp;类型的对象，上面也提到，对于普通类型的如无明确需要默认会调用普通版本的operator[]，因此需要将对象转换为const的，保证调用const operator[]，避免陷入无限递归。通过两个cast实现了避免代码重用。 条款04：确定对象被使用前已先被初始化RAII是老生常谈的话题了，构造函数的初始化也是C++ class的基础内容，还要注意的是初始化的顺序，首先是base class先于derived class的构造，另外构造函数中，构造的顺序跟class中声明的顺序是一致的（不是构造函数冒号后的顺序），当然如无必要最好还是应该避免构造过程中，相互使用类中的变量。 接下来还有一个问题就是，non-local static对象的使用问题。 如下面代码所示 12345678910111213141516171819202122// FileSystemclass FileSystem &#123;public: ... std::size_t numDisks() const; ...&#125;;extern FileSystem tfs;// Directory class Directory &#123;public: Directory(params); &#125;;Directory::Directory(params) &#123; ... std::size_t disks = tfs.numDisks(); ...&#125;Directory tempDir(params); 因为tfs不一定在tempDir构造之前完成了初始化，它们都是不同编译单元内的non-local static对象，它的初始化相对顺序是未定义的，使用起来会陷入未定义行为的危险当中，而要保证tfs在tempDir之前完成初始化，则需要寻找可确定的初始化顺序。而我们知道，函数中的static变量，在调用函数之前必然会被事先完成初始化，那么就可以利用这一点，将non-local static对象转化为local static对象，进而保证初始化完成，同时，保证只有一个对象。 12345678910111213141516171819202122232425262728// FileSystemclass FileSystem &#123;public: ... std::size_t numDisks() const; ...&#125;;FileSystem&amp; tfs() &#123; static FileSystem fs; return fs&#125;// Directory class Directory &#123;public: Directory(params); &#125;;Directory::Directory(params) &#123; ... std::size_t disks = tfs().numDisks(); ...&#125;Directory&amp; tempDir(params) &#123; static Directory td(params); return td;&#125; 当然了，要保证使用一个对象，返回值必然是引用的，这也是Singleton模式的常见实现方法。思想是：以local static对象替换non-local static对象。","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"leetcode(907)","slug":"leetcode-907","date":"2019-02-20T06:28:18.000Z","updated":"2019-02-20T07:19:50.317Z","comments":true,"path":"2019/02/20/leetcode-907/","link":"","permalink":"http://yoursite.com/2019/02/20/leetcode-907/","excerpt":"","text":"leetcode907题，题意很简单，就是计算数组所有的连续子数组的最小值的和。 有两种做法，一种是单调栈，一种是单调队列。 先说单调栈，思路就是找到数组中数字作为子数组最小值的左右边界，然后计算即可。如3 1 2 4，对于1来说，左边界就是最左端，右边界就是最右端，那么1作为最小值的子数组就有2×3个（离左端距离2，右端距离3），类似的，对2来说就是1×2。因此只需要计算得到每个数作为最小值的左右边界，即可完成。而要高效计算左右边界，则引入了单调栈的结构。 单调栈，顾名思义，它首先是一个栈，而且内部是单调有序的。使用单调栈的重要原因是，当我们从左到右，检测数字右边界的过程中，较大数能到达的右边界，那么它左边的较小数也能到达该右边界，因此可以统一处理，而较小数遇到了更小数的时候，较小数就不能继续到达右边界了。即查找右边界的时候，左边的数越小，越能到达该右边界。 计算左边界的思路同理，但是还有一个细节要注意的就是，左右边界的等号处理问题，就是遇到相同的数字的时候，要控制某一边的边界不变，来捕获大数组，而不构成重复，考虑3 1 2 3 1 4，碰到1的时候的处理细节即可。 AC代码： 1234567891011121314151617181920212223242526272829class Solution &#123;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; stack&lt;int&gt; st1, st2; int n = A.size(); vector&lt;int&gt; left(n, -1), right(n, n); for (int i=0;i&lt;n;++i) &#123; while (!st1.empty() &amp;&amp; A[st1.top()] &gt;= A[i]) &#123; right[st1.top()] = i; st1.pop(); &#125; st1.push(i); &#125; for (int i=n-1;i&gt;=0;--i) &#123; while (!st2.empty() &amp;&amp; A[st2.top()] &gt; A[i]) &#123; left[st2.top()] = i; st2.pop(); &#125; st2.push(i); &#125; int ans = 0; for (int i=0;i&lt;n;++i) &#123; ans += (left[i] - i) * (i-right[i]) * A[i]; ans %= 1000000007; &#125; return ans; &#125;&#125;; 时间和空间复杂度为O(n)。 接下来是单调队列的做法。单调队列是我最先想到的方法，但是初始版本的最坏复杂度过高，因此先放下来了。基本思路是这样的，比如说3 1 2 4，从左往右扫的过程中，先碰到3，3自然可以作为一个子数组，得到3，而继续扫的过程中，遇到了1，那么从3开始的数组，若碰到了1，那么接下来的最小值就是1了，另外，从1开始的数组，其子数组的最小值自然也是1，会得到队列1 1，接下来碰到了2，因为2比1小，所以2要作为最小值，只能重新开始作为新的子数组，而1可以继续延续作为子数组，得到队列1 1 2，到了4，队列就变成了1 1 3 4，最终结果就是每一个队列的和的和，这个和可以通过每一次的维护队列过程来进行维护。代码如下： AC代码： 123456789101112131415161718192021222324class Solution &#123;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; vector&lt;int&gt; que; int n = A.size(), sum = A[0]; que.push_back(A[0]); int cnt = 1, cur = A[0]; for (int i=1;i&lt;n;++i) &#123; int j = cnt - 1; while (j &gt;= 0 &amp;&amp; que[j] &gt; A[i]) &#123; cur = cur - que[j] + A[i]; que[j] = A[i]; j--; &#125; cnt++; cur += A[i]; que.push_back(A[i]); sum += cur; cur %= 1000000007; sum %= 1000000007; &#125; return sum; &#125;&#125;; 当然这个算法的最坏复杂度是O(n^2)，自然是不够看的。 实际上，可以发现队列是有序的，因此维护序列的过程中，可以通过二分查找来进行优化，优化之后结果的AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;private: int upperb(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;que, int size, int target) &#123; int left = 0; while (size &gt; 0) &#123; int half = size&gt;&gt;1; int mid = left+half; int idx = que[mid]; if (A[idx] &lt;= target) &#123; left = mid+1; size = size - half - 1; &#125; else &#123; size = half; &#125; &#125; return left; &#125;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); vector&lt;int&gt; que(n), cursum(n); que[0] = 0; cursum[0] = A[0]; int cur = 1, sum = A[0]; for (int i=1;i&lt;n;++i) &#123; int p = upperb(A, que, cur, A[i]); if (p == 0) &#123; cursum[0] = A[i]*(i+1); que[0] = i; cur = 1; &#125; else &#123; cursum[p] = cursum[p-1] + A[i]*(i-que[p-1]); que[p] = i; cur = p+1; &#125; sum += cursum[cur-1]; cursum[cur-1] %= 1000000007; sum %= 1000000007; &#125; return sum; &#125;&#125;; 最坏复杂度是O(nlogn)，不过这是一个比较松的上界，实际表现比上面的单调栈代码快一丢丢。 补充一个二分查找的写法，这里二分查找优化是需要自己写，而不能单纯使用upper_bound这些的，我个人比较喜欢的写法是stl标准库的写法，有个first，size，二分过程中用half，可以自己去查阅文档啦~","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]}]}