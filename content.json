{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"leetcode-(895)","slug":"leetcode-895","date":"2019-04-17T05:24:29.000Z","updated":"2019-04-17T05:40:18.993Z","comments":true,"path":"2019/04/17/leetcode-895/","link":"","permalink":"http://yoursite.com/2019/04/17/leetcode-895/","excerpt":"","text":"题意：维护一个频数栈，pop操作会将频数最高的元素pop出来，如果频数一致，那么就按入栈顺序，最后一个入栈的先pop出来，而push自定义，维护好pop的顺序即可。 思路：维护两个哈希表，即可，一个标记元素的频数，一个标记对应频数的栈，因为频数低的是不会被pop出去，因此只要保证每个频数最高的栈都是正确的即可，那么这个过程可以发现，当最高的频数减一的时候，回到次高的频数，对应的栈其实也是正确的。代码如下。 12345678910111213141516171819202122class FreqStack &#123;private: unordered_map&lt;int, int&gt; num2idx; unordered_map&lt;int, stack&lt;int&gt;&gt; cnt2st; int maxfreq;public: FreqStack(): maxfreq(0) &#123; &#125; void push(int x) &#123; int p = num2idx[x] += 1; maxfreq = max(maxfreq, p); cnt2st[p].push(x); &#125; int pop() &#123; int p = cnt2st[maxfreq].top(); cnt2st[maxfreq].pop(); num2idx[p] -= 1; if (cnt2st[maxfreq].size() == 0) maxfreq--; return p; &#125;&#125;; 此题记录的原因还有一个就是顺便记录一下map的操作，之前一直犹豫是否可以对map不存在的key进行操作，如cnt2[maxfreq].push(x)，查了一下官方文档，其实是合法的，这时候如果key不存在，那么会根据mapped_type默认构造函数构造一个出来（所以要求存在默认构造函数）。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"字节跳动笔试题","slug":"字节跳动笔试题","date":"2019-04-14T12:23:09.000Z","updated":"2019-04-14T12:46:53.051Z","comments":true,"path":"2019/04/14/字节跳动笔试题/","link":"","permalink":"http://yoursite.com/2019/04/14/字节跳动笔试题/","excerpt":"","text":"今天字节跳动的笔试题一共五道题，题数虽然多但是难度都不高。随意记录一下。 第一道，普通宽搜。 第二道，遍历一遍，新老map互相迭代使用。 第三道，可以数学推导结果，复杂度O(n)，也可以二分答案，复杂度O(nlogn)。 第四道，最短哈密尔顿回路，dfs超时，用状态压缩dp，dp过程类似Bellman-Ford算法，时间复杂度O(n^{2} 2^{n})。有个很诡异的卡内存点，定义全局变量会爆内存，但是可以声明一个vector的，同等大小而不爆内存，STL的实现本身也是在heap上面分配的内存，尚不明为什么可以用vector不爆内存，而全局变量会爆。 第五道，贪心，题意不算很清晰，主要原因还是样例给的数据量太小没有参考意义，实际题意是过河只有一艘船，船上至少要有两个人，最多三个，那么就表示过河可以三个人过，而船必须返回继续载人，此时要保证穿上有两个人。贪心策略应该是河两边都有两个较小耗时的人，这样就能在后续保证，过河过程中可以载两个比较耗时的人，而船回去的时候，能够以较短的时间返回到对岸继续载人。一开始没有看清楚题意，所以只A了九分之一，遗憾没有AK，这是笔试后重新回顾题意想的策略，应该没问题。","categories":[],"tags":[]},{"title":"leetcode-(947)","slug":"leetcode-947","date":"2019-04-10T12:07:37.000Z","updated":"2019-04-10T13:30:21.990Z","comments":true,"path":"2019/04/10/leetcode-947/","link":"","permalink":"http://yoursite.com/2019/04/10/leetcode-947/","excerpt":"","text":"题意：给定一个grid，上面有一些石头，哪里有石头，我们就可以以它的位置出发，取出同行或同列的一个石头，问最多能取到多少个石头。 思路：难点在于在复杂的情况下，就是列交上行再交上列，如此交错的情况下，怎么样取才是最优的，能取到最多的石头。而另一方面，我们可以发现，在这样的交错情况下，我们可以把这些石头划为同一个区域，最终能取得的最多石头数量，必然是区域内的石头数量减1，就是有办法最大化石头的取法。如此下来，就可以发现，我们能取到的最大石头数量其实就等于石头总数量减去总的区域数量。而区域的划分的方法也是根据这样的取法而来的，就是哪里有石头，哪里的行和列就能划为同一区域。这个过程也可以发现，其实行和列的概念并没有那么明显，也就是说，我们并不需要二维的空间，只需要把列（行）映射到一起，用一维的空间就够了。而计算区域数量，自然是想到了并查集，同区域的归并到同一个集合里去，最后数集合的数量那就是区域的数量。 12345678910111213141516171819202122232425262728class Solution &#123;private: void unionx(vector&lt;int&gt; &amp;ms, int x, int y) &#123; int sx = find(ms, x), sy = find(ms, y); if (sx != sy) &#123; ms[sx] = sy; &#125; &#125; int find(vector&lt;int&gt; &amp;ms, int x) &#123; int sx = x; while (ms[sx] != -1) &#123; sx = ms[sx]; &#125; return sx; &#125;public: int removeStones(vector&lt;vector&lt;int&gt;&gt;&amp; stones) &#123; vector&lt;int&gt; ms(20000, -1); for (auto &amp;stone: stones) &#123; unionx(ms, stone[0], stone[1]+10000); &#125; set&lt;int&gt; st; for (auto &amp;stone: stones) &#123; st.insert(find(ms, stone[0])); &#125; return stones.size() - st.size(); &#125;&#125;; 由此也联想到之前腾讯笔试的一道题目，同样也是有一个grid，上面有一些苹果，我们一次操作能消除一行，一列或是一个45度斜线上的苹果，问，最少用多少次操作，能够把所有苹果消去。当时想的做法是直接深搜，对于每个苹果可能出现的消除情况是四种（四个方向），那么深搜加剪枝即可完成。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"百度笔试题","slug":"百度笔试题","date":"2019-04-10T02:54:07.000Z","updated":"2019-04-10T11:55:56.795Z","comments":true,"path":"2019/04/10/百度笔试题/","link":"","permalink":"http://yoursite.com/2019/04/10/百度笔试题/","excerpt":"","text":"第一道题目题意：给定两个整数N和M，求长度为N+1的序列，要求序列第一个数字和最后一个数字均为1，而中间的数字可以从1-M种取，并且序列中相邻的数字不能是相同的，求这样的序列的数量是多少个。 思路1：这是环形染色问题的特殊版本，染色问题一般来说都是让相邻的区域染上不相同的颜色即可，而环形染色问题就是要求首末位置是相邻的，那么染一圈回来发现位置重了则是不能接受的，那么应该怎么处理呢？简单来说，就是分两种情况，因为我们知道一维的染色问题的结果很简单直接就是m*(m-1)^{n-1}，那环形染色我们可以这样想，假设n个区域的环形，我们要对它进行染色，其方案数目是a_{n}，那么它实际上就是对长度为n+1的一维线性序列进行染色结果首末位置的颜色相同的情况，而对于而剩下的情况，也就是一维序列里面首末位置颜色不一样的情况，我们可以想象在其末尾插入与首位置颜色相同的颜色，就会得到a_{n+1}的方案数目，所以就有 a_{n} + a_{n+1} = m*(m-1)^n ，这个通项公式是比较容易求的。而对于这道笔试题来说，只是首位置的颜色被确定了，所以最终结果除以m即可。 思路2：不从环形染色的角度去想，我们其实也可以推导出动态规划的状态转移公式，对于长度为n+1的序列，如果我们知道长度为n的序列，只需要在末尾再插入一个数字即可，方案数为m-2，此时可以注意到因为中间插入了数字，所以倒数第三位变得可以为1了，那此时就可以使用长度为n-1的序列，再其末尾1前面添加一个1，并在两个1中添加新的数字即可，一共有m-1中方案。那么这两种是否有重复的或者有遗漏的呢？其实我们可以发现这样的方法实际上只是区分了两种情况，倒数第三位是否为1，而我们假设n-1和n的情况都是正确的，因此通过数学归纳容易证明这样的计算方法是正确的。递推公式为a_{n+1} = (m-1)a_{n-1} + (m-2)a_n，这种递推公式可以使用特征根方程来求解得到，结果跟思路1的结果是完全一致的。 再补充一句，在数据量小的情况下，使用递推公式应该没什么问题，但是在大数据的情况下我们就需要求得其通项公式了，并且因为有指数运算，必须使用快速幂乘法，这样就能以O(logn)的复杂度求解到答案。 第二道题目，印象不是很深，因为题意其实有点不清楚，最后的结果需要套用乘法逆元，而主干的题目是一道记忆化搜索求期望的题目。","categories":[],"tags":[]},{"title":"leetcode-(940)","slug":"leetcode-940","date":"2019-04-09T12:58:18.000Z","updated":"2019-04-10T01:56:03.067Z","comments":true,"path":"2019/04/09/leetcode-940/","link":"","permalink":"http://yoursite.com/2019/04/09/leetcode-940/","excerpt":"","text":"题意：给定一个字符串，求有多少个不一样的子序列。 思路1：记忆化搜索，设有一个空的系列头，要求不一样的子序列，显然就要想办法把重复的情况去掉，那么如何去掉了，方法就是排在前面的先出现的字母能构成的子序列用于计算，而排在后面的字母只用于扩展的序列数目，比如说“abaca”，第一个a，第一个b，第一个c是用来计算子序列个数的， 而第二个a因为以第一个a为第一个字母的子序列必然会包括以第二个a为开头的子序列，所以避免重复，只计算第一个a的即可。扩展的过程就很简单了，以第一个a为开头的节点加上后面的字母为开头能构成的子序列的数量再加一即可。以该例子来说，以a开头的子序列的数量，就是以b开头的子序列数量+以c开头的子序列的数量+以第二个a为开头的子序列的数量，最后因为a自己也是一个子序列之一，所以额外加上1即可。这样就算了以a开头的子序列数量了，而这也是为什么要加上一个空序列头的原因，这样就能够直接写记忆化搜索实现了。 1234567891011121314151617181920212223242526272829303132333435class Solution&#123; private: int dfs(const string &amp;str, int from, vector&lt;int&gt; &amp;dp) &#123; if (dp[from] != -1) &#123; return dp[from]; &#125; bool vis[26] = &#123;false&#125;; int length = str.length(); dp[from] = 0; for (int i = from + 1; i &lt; length; ++i) &#123; int idx = str[i] - 'a'; if (!vis[idx]) &#123; vis[idx] = true; dp[from] += dfs(str, i, dp) + 1; // cout &lt;&lt; from &lt;&lt; \" \" &lt;&lt; str[i] &lt;&lt; dp[from] &lt;&lt; endl; dp[from] %= int((1e9) + 7); &#125; &#125; return dp[from]; &#125; public: int distinctSubseqII(string S) &#123; int length = S.length(); vector&lt;int&gt; dp(length + 1, -1); dfs(string(\"?\") + S, 0, dp); return dp[0]; &#125;&#125;; 算法复杂度是O(n^2)。 思路2：第一种思路是以序列头来考虑，并找到合适的转移方案来防止重复计算的，那么思路2就是换一种思路，以序列尾来考虑，因为要求”abaca”的子序列数量，而当我们知道”abac”的子序列数量的时候，添加一个a上去之后，能够得到的子序列数量应该如何计算呢？因为以a为结尾的序列数量我们都可以记录得到，那么新序列的数量可以把原来那些以a为结尾的全部拿掉，剩下的，它们分为加a或者不加a就可以了，然后还要注意的是原来以a结尾那一部分，加上一个a自然也是一个新的子序列，而它们本身就能够被不以a为结尾的子序列们，加上a来产生得到。这种思路跟上一种类似，上面说到以某个字母开头的序列数，我们只需要数最前面那个就可以，而取最后面的字母的序列数，其实我们也是取最后一个字母的就可以了。值得注意的是还有仅有一个a的情况也要考虑，才不会漏掉所有的情况。 123456789101112131415161718class Solution&#123; public: int distinctSubseqII(string S) &#123; int ends[26] = &#123;0&#125;; int length = S.length(); int res; int mod = (1e9) + 7; for (auto ch : S) &#123; int added = (res - ends[ch - 'a'] + 1) % mod; res = (res + added) % mod; ends[ch - 'a'] = (ends[ch - 'a'] + added) % mod; &#125; return res; &#125;&#125;; 算法复杂度是O(n)，因为不用往后去找后续的序列，在从前往后扫的过程中已经把前置的序列完成了。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode-(960)","slug":"leetcode-960","date":"2019-04-09T03:44:53.000Z","updated":"2019-04-09T11:13:34.185Z","comments":true,"path":"2019/04/09/leetcode-960/","link":"","permalink":"http://yoursite.com/2019/04/09/leetcode-960/","excerpt":"","text":"题意：给定n个长度相等的字符串，问最少删掉多少列能够使得每一个字符串中的字符都是按字典序排好的。 思路：最长上升子序列的变种。 1234567891011121314151617181920212223242526272829class Solution &#123;private: bool check(vector&lt;string&gt; &amp;A, int i, int j) &#123; int m = A.size(); for (int k=0;k&lt;m;++k) &#123; if (A[k][i] &gt; A[k][j]) &#123; return false; &#125; &#125; return true; &#125;public: int minDeletionSize(vector&lt;string&gt;&amp; A) &#123; int n = A.size(), m = A[0].length(); vector&lt;int&gt; dp(m, 1); for (int i=1;i&lt;m;++i) &#123; for (int j=0;j&lt;i;++j) &#123; if (check(A, j, i)) &#123; dp[i] = max(dp[i], dp[j]+1); &#125; &#125; &#125; int maxlen = 0; for (int i=0;i&lt;m;++i) &#123; maxlen = max(maxlen, dp[i]); &#125; return m-maxlen; &#125;&#125;; 这样的方法复杂度是O(nm^2)。当然了，最长上升子序列还有O(nmlogm)的做法，类似于插入排序找插入位置的二分查找思路。 而本次记录不仅仅是最长上升子序列那么简单，因为看别人的题解的时候看到了C++ lambda表达式的写法，想起自己一直觉得C++的fp有点怪怪的一直没有使用，刚好看到就稍微把用法记录一下吧。 首先是匿名函数的写法，将代码可以修改为 12345678910111213141516171819202122232425class Solution&#123; public: int minDeletionSize(vector&lt;string&gt; &amp;A) &#123; int n = A.size(), m = A[0].length(); vector&lt;int&gt; dp(m, 1); for (int i = 1; i &lt; m; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (all_of(A.begin(), A.end(), [=](string v) &#123; return v[j] &lt;= v[i]; &#125;)) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; &#125; int maxlen = 0; for (int i = 0; i &lt; m; ++i) &#123; maxlen = max(maxlen, dp[i]); &#125; return m - maxlen; &#125;&#125;; 注意，上面的代码就将check的过程转换成all_of加lambda函数实现了。这是C++11的写法，在C++14中，多得匿名函数的参数也可以用auto表示，更加智能，算是实现了Generic lambdas，当然C++14中的auto还能用到普通函数的类型推导上面，不过写起来总有那么一丝丝的不安吧… 而其中all_of的写法也可以切换成更普通的高阶函数来实现，也就是reduce, map。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution&#123; private: bool check(vector&lt;string&gt; &amp;A, int i, int j) &#123; int m = A.size(); for (int k = 0; k &lt; m; ++k) &#123; if (A[k][i] &gt; A[k][j]) &#123; return false; &#125; &#125; return true; &#125; public: int minDeletionSize(vector&lt;string&gt; &amp;A) &#123; int n = A.size(), m = A[0].length(); vector&lt;int&gt; dp(m, 1); for (int i = 1; i &lt; m; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; vector&lt;bool&gt; p(n, 0); transform(A.begin(), A.end(), p.begin(), [=](string v) &#123; return v[j] &lt;= v[i]; &#125;); if (accumulate(p.begin(), p.end(), true, [=](bool x, bool y) &#123; return x &amp;&amp; y; &#125;)) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; &#125; int maxlen = 0; for (int i = 0; i &lt; m; ++i) &#123; maxlen = max(maxlen, dp[i]); &#125; return m - maxlen; &#125;&#125;; 这里注意transform的参数，还有accumulate的使用。 当然了，这些函数的使用对空间和时间复杂度消耗也是很大的，而编程便利方面却不如python。不过值得一提的是，毕竟这些函数都是源自于函数式编程，函数本身天然有支持并行计算的能力，所以在C++17后面会慢慢支持使用并行计算对这些方法的优化，那时候就真正能够提高程序的效率了。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode-(137)","slug":"leetcode-137","date":"2019-04-03T12:37:53.000Z","updated":"2019-04-03T13:01:32.587Z","comments":true,"path":"2019/04/03/leetcode-137/","link":"","permalink":"http://yoursite.com/2019/04/03/leetcode-137/","excerpt":"","text":"题意是给出一个数组，里面只有一个数字只出现了一次，其他数字都出现了三次，找出那一个只出现过一次的数字。 解法：又是有趣的位运算题，这道题其实跟两次的类似，可以换到三进制去做，但是学过数字电路，离散数学什么的，就应该能比较容易想到位运算的做法。我们的目的是输入信号，输入一次的能得到本身，而输入三次能返回到初始状态，那么最终我们就能得到那一个只出现了一次的数字。显然有三个状态，我们则需要两个变量来模拟这个过程。给定输入信号，并对状态编码，则有如下的真值表。 a b input a_out b_out 0 0 0 0 0 0 1 0 0 1 1 0 0 1 0 0 0 1 0 1 0 1 1 1 0 1 0 1 0 0 如上便实现了我们所需要的三个状态，已经三次转移状态回到本身的过程了，而最终要取的数显然就是b_out了，因为当只输入一个1的时候，状态b_out才是正确反应输入的（如果题目改为只有一个数出现了两次的话要取哪个就不用直说了吧）。接下来就是逻辑表达式的换算了，我们总要利用逻辑运算，而不是简单的判断得到output的嘛。 乍看下来的表达式是这样子的： a_out = a(~b)(~i) + (~a)bib_out = (~a)b(~i) + (~a)(~b)i显然b_out能够轻松表示成(~a)(b xor i)。而结合b_out来看的话，其实a_out也能表示成这样的形式a_out = a(~i)(~b_out)+(~a)i(~b_out)，也就是说，跟b_out原来的形式非常相似了，于是就有a_out表示成(~b_out)(i xor a)。 于是问题就能轻而易举地优美解决掉了。 1234567891011class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int a_out = 0, b_out = 0; for (auto x: nums) &#123; b_out = (~a_out) &amp; (b_out ^ x); a_out = (~b_out) &amp; (a_out ^ x); &#125; return b_out; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode-(312)","slug":"leetcode-312","date":"2019-04-03T11:53:37.000Z","updated":"2019-04-03T12:34:31.265Z","comments":true,"path":"2019/04/03/leetcode-312/","link":"","permalink":"http://yoursite.com/2019/04/03/leetcode-312/","excerpt":"","text":"就是算法导论上面讲解动态规划的时候最经典的矩阵链乘题目，枚举区间，起点终点，中间点，动态规划即可。貌似也是昨天的网易游戏笔试题目。 代码如下： 1234567891011121314151617181920212223242526class Solution&#123; public: int maxCoins(const vector&lt;int&gt; &amp;_nums) &#123; int n = _nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 2, vector&lt;int&gt;(n + 2, 0)); vector&lt;int&gt; nums(n + 2, 1); for (int i = 0; i &lt; n; ++i) &#123; nums[i + 1] = _nums[i]; &#125; for (int len = 1; len &lt;= n; ++len) &#123; for (int from = 1; from &lt;= n - len + 1; from++) &#123; int to = from + len - 1; for (int mid = from; mid &lt;= to; mid++) &#123; dp[from][to] = max(dp[from][to], dp[from][mid - 1] + nums[from - 1] * nums[mid] * nums[to + 1] + dp[mid + 1][to]); &#125; &#125; &#125; return dp[1][n]; &#125;&#125;; 当然啦，这篇博客也不是仅仅是这道题目那么简单，顺便回想一下之前的题目，石子归并，也是一样的套路题目，但是加法相对于乘法有一个可以很大程度上优化的方法，单纯矩阵链乘在没有其他条件的时候只能达到O(n^3)的时间复杂度（维基百科上面有个O(nlogn)的，但是太复杂。而石子归并的就有一个很经典的优化方法，叫做平行四边形优化方法，基本原理就是跟区间相关的时候，存在不等式w(a,c) + w(b,d) \\leq w(a,d) + w(b, c)，其中a < b \\leq c < d，那么说明当中间存在最优方案的时候，都可以按照这样的方案去做，其他方案也不会优于这种方案。在这种区间dp的问题下面，说的就是当(a, b)和(c,d)中其最优方案分别是s1, s2，那么(a,d)的最优方案必然在s1和s2中产生，通过这样的优化，最后的复杂度可以降到O(n^2)。在石头合并上能够这样做的大致原因在于加法总的和是一定的，不一定的只是合并的过程，但是链乘上，乘法再相加则不一定存在这样的性质，而需要其他条件去补充，因此不能使用平行四边形优化。","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"网易游戏笔试题-莫比乌斯反演","slug":"网易游戏笔试题-莫比乌斯反演","date":"2019-04-03T07:05:22.000Z","updated":"2019-04-03T13:04:50.423Z","comments":true,"path":"2019/04/03/网易游戏笔试题-莫比乌斯反演/","link":"","permalink":"http://yoursite.com/2019/04/03/网易游戏笔试题-莫比乌斯反演/","excerpt":"","text":"题意是给出一个数组，要求三元组(a,b,c)，使得gcd(a,b,c)=1，求这些三元组的数量。数组大小和数的范围都是1到1e5。 一开始想的是基本的容斥原理，后来大佬说到可以直接套莫比乌斯反演，没想到有限域学到的莫比乌斯反演能这样用（查了一下才发现是基本NOI，ACM的模板题了，之前还没见过orz）。 学习了一下，首先先简单介绍一下莫比乌斯反演。其公式表示如下： b(n) = \\sum_{d|n}a(d) \\iff a(n)=\\sum_{d|n} \\mu(\\frac{n}{d})b(d)证明过程就简略了，主要思想就是将一个较难做的$a(n)$函数，转化成较简单的$b(n)$去求解，有限域上给的应用例子是欧拉函数相关的， \\sum_{d|n}\\phi(d) = n ，因为直接计算欧拉函数复杂度稍高，那么就可以通过转化来计算欧拉函数\\phi(n)=\\sum_{d|n}\\mu(d)\\frac{n}{d}。 介绍最直接的莫比乌斯反演入门题，就是给两个区间，从每个区间各取一个数，求有多少对互素的数。直接求gcd(a,b)==1的数量复杂度较高，那么可以转换一下求1 | gcd(a,b)的数量，因为那是可以直接求到的，如枚举$k=2$时，就只需要求两个区间内的偶数数量，然后做组合数即可，两次除法一次乘法，从而从简单问题的角度解决了较难的问题（此处扩展来说就不一定是素数了，把1改成其他数即可）。唔 可能有人会问对应的$n$和$d$是什么，我也有这样的疑问，而我的想法是，$n$甚至可以是那段阶乘，所以实际计算过程需要遍历区间内每一个数。 那么回到笔试题目来，题目给出的是可能包含重复数的正整数数组，要求三元组，那么就使用同样的套路即可，尽管不是连续的整数，但是函数的表达还是一样的要求$gcd(a,b,c)==1$的数量，转换成求$1 | gcd(a,b,c)$的数量，然后套上莫比乌斯反演公式即可。而因为此处不是连续的数字，所以可能要花点功夫，因为数的范围还是1e5，因此可以将数都放到桶里面方便取，然后间隔着去找$gcd(a,b,c)=k % 1 == 0$的数量，如要$k$的，那就从$k$开始，取$k$, $2k$, $3k$的数即可，这里要注意一点就是，我们求的是$cd(a,b,c)=k % 1 == 0$的数量，因此尽管$buckets[k]$可能为0，但是那一系列数还是能取到满足要求的，那么是否会重复计数呢？公式里面其实就已经考虑了这个问题，所以不用担心（逃）。 代码如下，添加了一个暴力的用于检验答案对错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;ctime&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;// const int maxn = 1000000 + 10;int gcd(int x, int y)&#123; if (x % y == 0) return y; else return gcd(y, x % y);&#125;int baoli(const vector&lt;int&gt; &amp;arr)&#123; int ans = 0; for (int i = 0; i &lt; arr.size(); ++i) &#123; for (int j = i + 1; j &lt; arr.size(); ++j) &#123; for (int k = j + 1; k &lt; arr.size(); ++k) &#123; if (gcd(gcd(arr[i], arr[j]), arr[k]) == 1) &#123; ans++; &#125; &#125; &#125; &#125; return ans;&#125;const int maxn = 100000 + 10;int buckets[maxn];int mu[maxn], vis[maxn], primes[maxn];int cnt;void getmu()&#123; memset(vis, 0, sizeof(vis)); memset(mu, 0, sizeof(mu)); cnt = 0; mu[1] = 1; for (int i = 2; i &lt;= maxn; ++i) &#123; if (!vis[i]) &#123; primes[cnt++] = i; mu[i] = -1; &#125; for (int j = 0; j &lt; cnt &amp;&amp; primes[j] * i &lt;= maxn; ++j) &#123; vis[primes[j] * i] = 1; if (i % primes[j] == 0) break; mu[i * primes[j]] = -mu[i]; &#125; &#125;&#125;int maxi = 0, n = 0;long long solve()&#123; long long f = 0; for (int i = 1; i &lt;= maxi; ++i) &#123; long long p = 0; for (int j = i; j &lt;= maxi; j += i) &#123; p += buckets[j]; &#125; f += mu[i] * p * (p - 1) * (p - 2) / 6; &#125; return f;&#125;int main()&#123; getmu(); cin &gt;&gt; n; vector&lt;int&gt; arr(n); memset(buckets, 0, sizeof(buckets)); srand(0); for (int i = 0; i &lt; n; ++i) &#123; // cin &gt;&gt; arr[i]; arr[i] = rand() % 100000 + 1; buckets[arr[i]] += 1; maxi = max(maxi, arr[i]); // cout &lt;&lt; arr[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; // cout &lt;&lt; baoli(arr) &lt;&lt; endl; cout &lt;&lt; solve() &lt;&lt; endl; return 0;&#125; 当然了，莫比乌斯反演其实也是对容斥问题的求解思路，因此，这道题也可以按照这个思路有容斥问题的解法，具体应该是选出3元组的方式的数量减去gcd不为1的数量，而遇到2，3得6这种情形，就要把6的那部分加回来（很像$\\mu$函数了…）。 还有一个算法复杂度的问题，就是solve那两重循环的复杂度应该是多少，实际上可以发现第二重循环时$ln(n)$的泰勒展开，所以整个复杂度时$O(nlog(n))$的，而莫比乌斯反演需要用到的$mu$的计算方法时$O(n)$的，所以整个算法复杂度是$O(nlog(n))$。","categories":[],"tags":[]},{"title":"muduo-(2)","slug":"muduo-2","date":"2019-03-27T11:54:23.000Z","updated":"2019-04-03T13:23:33.438Z","comments":true,"path":"2019/03/27/muduo-2/","link":"","permalink":"http://yoursite.com/2019/03/27/muduo-2/","excerpt":"","text":"首先复习（预习）一下进程和线程的概念，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元，而线程是进程执行的基本单位，一个进程至少拥有一个进程，也可以拥有多个线程。区别在于线程没有地址空间，线程包含在进程的地址空间中。线程上下文只包含一个堆栈、一个寄存器、一个优先权，线程文本包含在他的进程的文本片段中，进程拥有的所有资源都属于线程。所有的线程共享进程的内存和资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段， 寄存器的内容，栈段又叫运行时段，用来存放所有局部变量和临时变量。相对于线程的轻量级，进程的创建切换阻塞挂起都需要操作系统来直接管理。 子进程跟线程不一样，子进程概念来说操作系统会分配新的内存空间，相当于是一个新进程，但是pid与父进程不一致（fork返回值不一样）用于区分父子进程，而实际上为了优化内存，会使用写时复制技术，起初子进程使用的是虚拟空间，段中使用的还是父进程的，但当要修改相应段需要修改时（如正文段，数据段，堆，栈），再复制相应的段，并修改，达到内存优化的效果。而对线程而言，分配的空间是直接地在进程的堆空间中分配，并有guardsize来限制线程栈空间（linux中ulimit -a查看，ulimit -s修改），防止踏入其他空间，造成段错误（segment fault）。 线程通信的话基于的都是进程中的共享变量和内存，主要通过互斥来解决共享数据读写的问题。而进程不一样，一般通过操作系统提供的工具来实现，如linux中的pipe，提供的通信方式是提供文件操作符，在父子或是兄弟进程之间进行单向的通信，如果要实现双向的通信则需要使用两个pipe（半双工）。因此，没有关系的进程之间的相互通信则受到了限制。文中推荐的是只使用TCP来完成通信，好处在于能够实现不同进程之间的通信，因为TCP的实现较为成熟，不仅是C++，更多语言的程序也能够直接通过TCP来进行通信，说白了就是一种通用的通信方式。同时，对于带“连接重试”的网络库来说，进程的启动都具有独立性，能够退出后再启动，重新连接继续工作，对开发牢靠的分布式系统意义巨大。同时，在TCP之上也能构建上层的通信协议。而分布式系统中的长连接使用TCP来实现有点在于两个方面，一个是能够轻松定位分布式系统中的服务之间的依赖关系，通过netstat -tpna | grep :port就能查清服务的客户端地址。第二个则是接受和发送队列的长度都能够定位出网络或程序的故障。如Recv-Q保持不变或是持续增加，那么往往意味着服务进程的处理速度变慢，可能出现了死锁或阻塞。而Send-Q保持不变或持续增加，那么就可能代表对方服务器太忙，处理不过来了，也可能是网络环境出现问题，导致了丢包，或者对方掉线了。这都是可以通过Recv-Q和Send-Q能完成的异常定位。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"muduo-(1)","slug":"muduo-1","date":"2019-03-21T11:59:57.000Z","updated":"2019-03-21T12:49:10.830Z","comments":true,"path":"2019/03/21/muduo-1/","link":"","permalink":"http://yoursite.com/2019/03/21/muduo-1/","excerpt":"","text":"现在转到muduo这本书里学习一下关于C++多线程和网络编程的一些事情，读过一遍之后准备深入到unix网络编程里面，学习一下后台开发相关的一些内容，希望还能实现一个像handy那样的C++网络库。 首先从第二章开始，学习线程同步相关的内容。 回顾一下死锁的概念，死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。那么死锁有四个必要条件，互斥（某种资源只能一个进程访问），占有且等待（进程占有着资源并等待它所要的资源），不可抢占（别人的资源不能抢过来），循环等待（进程相互之间的等待构成了循环，死锁的直接原因）。要解决死锁，那就是解决这四个必要条件。 比如说如下的代码，MutexLockGuard lock(mutex);用RAII手法来封装mutex的创建，销毁，加锁，解锁，非常有效。但是如下的代码中可能出现traverse()已经对全局的mutex加锁，保证foos的数据正确，然后要求执行post()，但是post()又希望将资源锁起来，保证foos不被其他线程破坏，就造成了死锁。此处使用递归锁当然可以保证这个线程不被自己锁起来，但是也有可能使得foos的迭代器失效，造成程序的crash。解决方法是使用将foos转为shared_ptr型的，要求traverse()的时候，以较低的开销构建一份拷贝出来，而post()则可以使用互斥锁来保证数据的安全。 12345678910111213141516171819202122232425262728293031323334353637class Foo&#123; public: void doit() const;&#125;;MutexLock mutex;std::vector&lt;Foo&gt; foos;void post(const Foo&amp; f)&#123; MutexLockGuard lock(mutex); foos.push_back(f);&#125;void traverse()&#123; MutexLockGuard lock(mutex); for (std::vector&lt;Foo&gt;::const_iterator it = foos.begin(); it != foos.end(); ++it) &#123; it-&gt;doit(); &#125;&#125;void Foo::doit() const&#123; Foo f; post(f);&#125;int main()&#123; Foo f; post(f); traverse();&#125; 上面是一个进程使用一把锁把自己死锁了的情形，而实际上还有一种很常见的互锁情形，而且不易被发现。下面代码就是这样的情形，实际上简化锁请求的过程很简单就是AB和BA，每个类都攥着自己的锁等待对方的锁释放，造成了死锁。简单的解决方法就是像注释替换那样，做一份拷贝，那样printAll的时候就没有必要加锁了，但是拷贝的开销太大。也可以换一下锁的顺序，变成同样的锁请求顺序AB和AB这样就不会死锁了，但是没有办法解决析构过程中的race condition问题（析构完再print问题就大了）。而前面做一份拷贝确实有效，只是开销大，因此可以尝试用shared_ptr优化，但是实际上析构的race condition问题并没有彻底解决，毕竟shared_ptr是基于引用计数，而直接传递this指针，会破坏智能指针的语义，产生错误，那么就可以尝试C++11的新特性，enable_shared_from_this来进行优化。代码在更下面一点。那么可不可以使用weak_ptr呢？书上好像没有提到，我觉得是有办法的，跟第一章的例子一样，但是代码的语义可能就有所变化了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798class Request;class Inventory&#123;public: void add(Request *req) &#123; muduo::MutexLockGuard lock(mutex_); requests_.insert(req); &#125; void remove(Request *req) __attribute__((noinline)) &#123; muduo::MutexLockGuard lock(mutex_); requests_.erase(req); &#125; void printAll() const;private: mutable muduo::MutexLock mutex_; std::set&lt;Request *&gt; requests_;&#125;;Inventory g_inventory;class Request&#123;public: void process() // __attribute__ ((noinline)) &#123; muduo::MutexLockGuard lock(mutex_); g_inventory.add(this); // ... &#125; ~Request() __attribute__((noinline)) &#123; muduo::MutexLockGuard lock(mutex_); sleep(1); g_inventory.remove(this); &#125; void print() const __attribute__((noinline)) &#123; muduo::MutexLockGuard lock(mutex_); // ... &#125;private: mutable muduo::MutexLock mutex_;&#125;;void Inventory::printAll() const&#123; muduo::MutexLockGuard lock(mutex_); sleep(1); for (std::set&lt;Request *&gt;::const_iterator it = requests_.begin(); it != requests_.end(); ++it) &#123; (*it)-&gt;print(); &#125; printf(\"Inventory::printAll() unlocked\\n\");&#125;/*void Inventory::printAll() const&#123; std::set&lt;Request*&gt; requests &#123; muduo::MutexLockGuard lock(mutex_); requests = requests_; &#125; for (std::set&lt;Request*&gt;::const_iterator it = requests.begin(); it != requests.end(); ++it) &#123; (*it)-&gt;print(); &#125;&#125;*/void threadFunc()&#123; Request *req = new Request; req-&gt;process(); delete req;&#125;int main()&#123; muduo::Thread thread(threadFunc); thread.start(); usleep(500 * 1000); g_inventory.printAll(); thread.join();&#125; 比较正确的做法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122class Request;typedef boost::shared_ptr&lt;Request&gt; RequestPtr;class Inventory&#123;public: Inventory() : requests_(new RequestList) &#123; &#125; void add(const RequestPtr &amp;req) &#123; muduo::MutexLockGuard lock(mutex_); if (!requests_.unique()) &#123; requests_.reset(new RequestList(*requests_)); printf(\"Inventory::add() copy the whole list\\n\"); &#125; assert(requests_.unique()); requests_-&gt;insert(req); &#125; void remove(const RequestPtr &amp;req) // __attribute__ ((noinline)) &#123; muduo::MutexLockGuard lock(mutex_); if (!requests_.unique()) &#123; requests_.reset(new RequestList(*requests_)); printf(\"Inventory::remove() copy the whole list\\n\"); &#125; assert(requests_.unique()); requests_-&gt;erase(req); &#125; void printAll() const;private: typedef std::set&lt;RequestPtr&gt; RequestList; typedef boost::shared_ptr&lt;RequestList&gt; RequestListPtr; RequestListPtr getData() const &#123; muduo::MutexLockGuard lock(mutex_); return requests_; &#125; mutable muduo::MutexLock mutex_; RequestListPtr requests_;&#125;;Inventory g_inventory;class Request : public boost::enable_shared_from_this&lt;Request&gt;&#123;public: Request() : x_(0) &#123; &#125; ~Request() &#123; x_ = -1; &#125; void cancel() __attribute__((noinline)) &#123; muduo::MutexLockGuard lock(mutex_); x_ = 1; sleep(1); printf(\"cancel()\\n\"); g_inventory.remove(shared_from_this()); &#125; void process() // __attribute__ ((noinline)) &#123; muduo::MutexLockGuard lock(mutex_); g_inventory.add(shared_from_this()); // ... &#125; void print() const __attribute__((noinline)) &#123; muduo::MutexLockGuard lock(mutex_); // ... printf(\"print Request %p x=%d\\n\", this, x_); &#125;private: mutable muduo::MutexLock mutex_; int x_;&#125;;void Inventory::printAll() const&#123; RequestListPtr requests = getData(); printf(\"printAll()\\n\"); sleep(1); for (std::set&lt;RequestPtr&gt;::const_iterator it = requests-&gt;begin(); it != requests-&gt;end(); ++it) &#123; (*it)-&gt;print(); &#125;&#125;void threadFunc()&#123; RequestPtr req(new Request); req-&gt;process(); req-&gt;cancel();&#125;int main()&#123; muduo::Thread thread(threadFunc); thread.start(); usleep(500 * 1000); g_inventory.printAll(); thread.join();&#125; 那么enable_shared_from_this是怎么起作用的呢？示例是一段示例代码。 123456789101112131415161718class Bad&#123;public: std::shared_ptr&lt;Bad&gt; getptr() &#123; return std::shared_ptr&lt;Bad&gt;(this); &#125; ~Bad() &#123; std::cout &lt;&lt; \"Bad::~Bad() called\" &lt;&lt; std::endl; &#125;&#125;; int main()&#123; // 错误的示例，每个shared_ptr都认为自己是对象仅有的所有者 std::shared_ptr&lt;Bad&gt; bp1(new Bad()); std::shared_ptr&lt;Bad&gt; bp2 = bp1-&gt;getptr(); // 打印bp1和bp2的引用计数 std::cout &lt;&lt; \"bp1.use_count() = \" &lt;&lt; bp1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; \"bp2.use_count() = \" &lt;&lt; bp2.use_count() &lt;&lt; std::endl;&#125; 123456789101112131415161718192021struct Good : std::enable_shared_from_this&lt;Good&gt; // 注意：继承&#123;public: std::shared_ptr&lt;Good&gt; getptr() &#123; return shared_from_this(); &#125; ~Good() &#123; std::cout &lt;&lt; \"Good::~Good() called\" &lt;&lt; std::endl; &#125;&#125;; int main()&#123; // 大括号用于限制作用域，这样智能指针就能在system(\"pause\")之前析构 &#123; std::shared_ptr&lt;Good&gt; gp1(new Good()); std::shared_ptr&lt;Good&gt; gp2 = gp1-&gt;getptr(); // 打印gp1和gp2的引用计数 std::cout &lt;&lt; \"gp1.use_count() = \" &lt;&lt; gp1.use_count() &lt;&lt; std::endl; std::cout &lt;&lt; \"gp2.use_count() = \" &lt;&lt; gp2.use_count() &lt;&lt; std::endl; &#125; system(\"pause\");&#125; 而要实现线程安全的Singleton，也就是保证singleton不被初始化多次，借助的就是pthread_once，同时Singleton是noncopyable的，而实际上C++11能够保证static是线程安全的，也就是在新标准下直接使用static的singleton即可保证线程安全。 12345678910111213141516171819202122232425262728293031323334353637383940414243template&lt;typename T&gt;class Singleton : noncopyable&#123; public: Singleton() = delete; ~Singleton() = delete; static T&amp; instance() &#123; pthread_once(&amp;ponce_, &amp;Singleton::init); assert(value_ != NULL); return *value_; &#125; private: static void init() &#123; value_ = new T(); if (!detail::has_no_destroy&lt;T&gt;::value) &#123; ::atexit(destroy); &#125; &#125; static void destroy() &#123; typedef char T_must_be_complete_type[sizeof(T) == 0 ? -1 : 1]; T_must_be_complete_type dummy; (void) dummy; delete value_; value_ = NULL; &#125; private: static pthread_once_t ponce_; static T* value_;&#125;;template&lt;typename T&gt;pthread_once_t Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;template&lt;typename T&gt;T* Singleton&lt;T&gt;::value_ = NULL; 1234static Singleton&amp; get() &#123; static Singleton instance; return instance;&#125; 大致这就是在第二章学到的内容，还是比较粗浅的…希望用心过一遍之后，再到网络编程，网络库实现，之后回来能有新的心得体会。 再补充一个书上经常用到的复现死锁位置的技巧sleep(1)，这是有意在测试的时候，延长临界区，加速死锁的复现，而实际的代码中并不可以在等待资源的时候使用sleep而应该利用类似condition variable的方法，达到尽快拿到锁，访问数据，并不影响其他线程的效果。而读写锁方面也并不推荐，因为互斥锁已经能够安全地完成需求了，读写锁带来的性能提高并不大，同时也提高了bug暴露和定位的难度，安全性大大降低。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"leetcode-(1014)","slug":"leetcode-1014","date":"2019-03-20T12:42:51.000Z","updated":"2019-03-21T08:33:57.945Z","comments":true,"path":"2019/03/20/leetcode-1014/","link":"","permalink":"http://yoursite.com/2019/03/20/leetcode-1014/","excerpt":"","text":"就是最经典的二分答案题目，放上来顺便记录一下自己喜欢的二分写法还有排序的写法。 首先是题解，使用的是STL中实现的二分查找方式，也是我比较喜欢的一种，感觉比l和r什么的清晰易懂。 12345678910111213141516171819202122232425262728class Solution &#123;public: int shipWithinDays(vector&lt;int&gt;&amp; weights, int D) &#123; int first = 1, length = 0x3f3f3f3f; for (auto w: weights) first = max(first, w); while (length &gt; 0) &#123; int half = (length &gt;&gt; 1); int mid = first + half; int cnt = 1, car = 0; for (auto w: weights) &#123; car += w; if (car &gt; mid) &#123; car = w; cnt += 1; &#125; &#125; if (cnt &lt;= D) &#123; length = half; &#125; else &#123; first = mid + 1; length = length - half - 1; &#125; &#125; return first; &#125;&#125;; 上面的写法也可以作为lower_bound的实现方式，而upper_bound目的是找到第一个不满足的位置，因此实现如下， 12345678910111213141516template&lt;typename T&gt;size_t upper_bound(const std::vector&lt;T&gt; &amp;vec, const T &amp;value) &#123; std::size_t first = 0, length = vec.size(); while (length &gt; 0) &#123; size_t half = (length &gt;&gt; 1); size_t mid = first + half; if (vec[mid] &lt;= value) &#123; first = mid + 1; length = length - half - 1 &#125; else &#123; length = half; &#125; &#125; return first;&#125; 还有自己喜欢但是不太快也不太好理解的快速排序写法 123456789101112131415161718192021template&lt;typename T&gt;void quick_sort_helper(std::vector&lt;T&gt; &amp;vec, size_t from, size_t to) &#123; cout&lt;&lt;from&lt;&lt;\" \"&lt;&lt;to&lt;&lt;endl; T pivot = vec[from]; size_t left = from, right = to - 1; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; vec[right] &gt;= pivot) right--; swap(vec[left], vec[right]); while (left &lt; right &amp;&amp; vec[left] &lt;= pivot) left++; swap(vec[left], vec[right]); &#125; swap(vec[left], pivot); if (from &lt; left) quick_sort_helper(vec, from, left); if (left + 1 &lt; to) quick_sort_helper(vec, left+1, to);&#125;template&lt;typename T&gt;void quick_sort(std::vector&lt;T&gt; &amp;vec) &#123; std::size_t size = vec.size(); quick_sort_helper(vec, 0, size);&#125; 维基百科上面的写法，下面有一步需要比较是因为无法知道是第一重left循环找到不满足arr[left]&gt;=pivot但是右边没有可交换的元素还是遍历完成使得left==right的，如果是前者的情况，直接交换便能使得左边全是小于等于pivot的，右边全是大于等于pivot的。如果是后者情况，实际上会发现原因就是子数组全是小于等于end的位置的（因为如果找到位置交换了，那么必然也会找到大于end的，那么结果会属于前者情况），所以在这里只需要排序start到left的位置即可，完全不需要下一行，当然，减少代码重用还有美观的角度还是统一起来了，推导和实验都发现其实是没有必要的。 123456789101112131415161718192021222324template &lt;typename T&gt;void quick_sort_recursive(vector&lt;T&gt; &amp;arr, int start, int end) &#123; if (start &gt;= end) return; T mid = arr[end]; int left = start, right = end - 1; while (left &lt; right) &#123; while (arr[left] &lt;= mid &amp;&amp; left &lt; right) left++; while (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--; std::swap(arr[left], arr[right]); &#125; if (arr[left] &gt;= arr[end]) std::swap(arr[left], arr[end]); else left++; quick_sort_recursive(arr, start, left - 1); quick_sort_recursive(arr, left + 1, end);&#125;template &lt;typename T&gt;void quick_sort(vector&lt;T&gt; &amp;arr, int len) &#123; quick_sort_recursive(arr, 0, len - 1);&#125; 堆排序写法： 1234567891011121314151617181920212223242526272829303132333435template &lt;typename T&gt;void heap_sort_helper(vector&lt;T&gt; &amp;arr, size_t p, size_t size) &#123; while (p &lt; size / 2) &#123; size_t l = p*2+1, r = p*2+2; if (l &lt; size &amp;&amp; arr[p] &lt; arr[l]) &#123; if (r &lt; size &amp;&amp; arr[l] &lt; arr[r]) &#123; std::swap(arr[p], arr[r]); p = r; &#125; else &#123; std::swap(arr[p], arr[l]); p = l; &#125; &#125; else if (r &lt; size &amp;&amp; arr[p] &lt; arr[r]) &#123; std::swap(arr[p], arr[r]); p = r; &#125; else &#123; break; &#125; &#125;&#125;template &lt;typename T&gt;void heap_sort(vector&lt;T&gt; &amp;arr) &#123; size_t size = arr.size(); for (int i=size/2;i&gt;=0;--i) &#123; // 注意size_t永不小于0 heap_sort_helper(arr, i, size); &#125; for (size_t i=size-1;i&gt;0;--i) &#123; std::swap(arr[i], arr[0]); heap_sort_helper(arr, 0, i); &#125;&#125; 归并排序： 123456789101112131415161718192021222324252627282930313233343536373839template &lt;typename T&gt;void merge_sort_helper(vector&lt;T&gt; &amp;arr, size_t from, size_t to, vector&lt;T&gt; &amp;aux) &#123; if (from+1 &gt;= to) &#123; return; &#125; size_t mid = (from+to)&gt;&gt;1; merge_sort_helper(arr, from, mid, aux); merge_sort_helper(arr, mid, to, aux); size_t i = from, left = from, right = mid; while (left &lt; mid &amp;&amp; right &lt; to) &#123; if (arr[left] &lt; arr[right]) &#123; aux[i] = arr[left]; left++; &#125; else &#123; aux[i] = arr[right]; right++; &#125; i++; &#125; while (left &lt; mid) &#123; aux[i] = arr[left]; i++, left++; &#125; while (right &lt; to) &#123; aux[i] = arr[right]; i++, right++; &#125; for (size_t p=from;p&lt;to;++p) &#123; arr[p] = aux[p]; &#125;&#125;template &lt;typename T&gt;void merge_sort(vector&lt;T&gt; &amp;arr) &#123; size_t size = arr.size(); vector&lt;T&gt; aux(size); merge_sort_helper(arr, 0, size, aux);&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"effective-C++(7)","slug":"effective-C-7","date":"2019-03-19T11:30:40.000Z","updated":"2019-03-19T12:25:06.158Z","comments":true,"path":"2019/03/19/effective-C-7/","link":"","permalink":"http://yoursite.com/2019/03/19/effective-C-7/","excerpt":"","text":"条款41：了解隐式接口和编译期多态class的多态比较常见，它是以函数签名为中心，通过virtual实现的运行期多态，而template则是隐式的接口，通过template具现化和函数重载解析实现的多态，发生在编译期。编译期相对于运行期的优势就在于将代码的出错时间提早了，在编译期就能发现bug，而且编译期能够完成的东西，提前到编译期完成一般来说也能够提高运行期的效率。 条款42：了解typename的双重意义在模板上的typename和class意义其实是一样的，可以根据习惯随意调换使用。 12template&lt;typename T&gt; class Widget;template&lt;class T&gt; class Widget; 然而typename有一个更强大的作用就是用来显示告诉编译期接口的存在性，术语叫做从属名称，因为当我们使用模板的时候，对应的类型不一定有相应的接口或者变量参数（而且就算是模板，也存在偏特化的行为），站在编译器的角度为了保证安全，直接就会默认对应的接口不存在而报错，因此需要前置typename来告诉编译器默认其存在性。如下面的代码提示编译器C中会存在iterator，iterator属于C。 12template&lt;typename C&gt;void f(const C &amp;container, typename C::iterator iter); 当然也有特例，就是不允许使用typename的时候。 12345678template&lt;typename T&gt;class Derived: public Base&lt;T&gt;::Nested &#123; // typename not allowedpublic: explicit Derived(int x): Base&lt;T&gt;::Nested(x) // typename not allowed &#123; typename Base&lt;T&gt;::Nested temp; // typename needed &#125;&#125; 还有一个小细节就是，typedef的时候可别漏了typename的输入，算是一个小隐患。 条款43：学习处理模板化基类内的名称上面提到了typename的作用，其实可以替代而且更加直观的方法可以使用using，原理跟之前条款提到的一样，而且还可以使用this-&gt;，同样也是显示告诉编译器的方法，而且这样的方法在可读性方面也有不错的提高。 条款44：将与参数无关的代码抽离templatestemplate存在有代码膨胀的问题，看似防止了代码重复，实际上编译器在背地里生成了不少可能是重复的代码。因此当代码与参数无关的时候，应当把代码移出templates，已非template的方式实现，减少代码膨胀。 条款45：运用成员函数模板接受所有兼容类型原因在于template在类型转换方面能力比较糟糕，template&lt;typename T&gt;上，就算T能够相互转换也没有没有办法隐式或是显示转换，原文中有一句话是，SmartPtr&lt;Middle&gt;和SmartPtr&lt;Top&gt;的关系并不比vector&lt;float&gt;和Widget更密切，尽管Middle和Top是父子类关系，因此不能指望template能够帮你兼容其他类型，需要的是在成员函数中使用模板，让其适配其他类型。 条款46：需要类型转换时请为模板定义非成员函数前面的条款提到过一个关于Rational的案例就是，2*Rational的运算会出错，原因显然是int类型没有这样的乘法，那么需要设置non-member函数来实现它。而在template方面，则可以进一步扩展来实现。 12345678910template&lt;typename T&gt;class Rational &#123;public: ... friend Rational operator*(const Rational &amp;lhs, const Rational &amp;rhs); // 无须template&#125;;template&lt;typename T&gt;const Rational&lt;T&gt; operator*(const Rational&lt;T&gt; &amp;rhs, const Rational&lt;T&gt; &amp;lhs)&#123; ... &#125; 条款47：请使用traits classes表现类型信息Trait classes能够使得“类型相关信息”在编译期可用，也就是可以在编译期对类型进行if…else测试。 条款48：认识模板元编程接下来就是鼎鼎大名的所谓“图灵完备”的模板元编程，图灵完备意思是它能够强大到计算任何事物，包括声明变量，执行循环，编写和调用程序等等，而且在C++中这些都是编译期完成的。当然在C++中也不会有人要求编译期完成那么多活，但是灵活使用模板元编程确实提高运行速度的一个黑科技。 如计算阶乘的就可以通过模板元编程在编译期完成。 123456789template&lt;unsigned n&gt;struct Factorial &#123; enum &#123; value = n*Factorial&lt;n-1&gt;::value &#125;;&#125;;template&lt;&gt;struct Factorial&lt;0&gt; &#123; enum &#123; value = 1 &#125;;&#125;; 使用到的技术不仅有模板元编程，还有模板偏特化，定义了0的阶乘为1，而且利用了enum hack保证编译期将结果计算出来，而整体的思路有点类似于函数式编程。在代码使用中，只需要简单使用Factorial&lt;10&gt;::value，即可完成计算，复杂度看似$O(n)$，实际上编译期已经完成了计算，所以对于运行期来说它是常量的时间复杂度，唯一缺点就是不能动态地使用变量（常量还是可以的），Factorial&lt;n&gt;::value，毕竟模板还是编译期的行为。 那么还有比较高级的用法是编译期实现矩阵乘法，过于黑科技了就不赘述了…还不如去写fp… 总的来说，就是说明借助模板元编程可以将很多运行期的事情转移到编译期完成，来提高运行期的效率。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"leetcode-搬运老博客汇总","slug":"leetcode-搬运老博客汇总","date":"2019-03-19T02:35:27.000Z","updated":"2019-03-19T02:36:43.701Z","comments":true,"path":"2019/03/19/leetcode-搬运老博客汇总/","link":"","permalink":"http://yoursite.com/2019/03/19/leetcode-搬运老博客汇总/","excerpt":"","text":"好像是大二还是大三的算法课上老师要求刷leetcode写博客，然后我当时已经刷了不少题了，就直接堆了题目数量，做了一个当时的小汇总，现在搬运一下（偷懒），嘿嘿。 1. Two Sum用map建立number-&gt;index映射即可。 2. Add Two Numbers利用链表的基本操作来模拟高精度相加过程，链表头为最低位 3. Longest Substring Without Repeating Characters贪心，从头开始扫，遇到重复了，若上一个位置为i，则将i之前的字母去掉，继续贪心即可。 4. Median of Two Sorted Arrays二分+递归，扩展到找到两个数组的第k大来进行二分搜索。设两个数组分别为num1, num2，要找第k大，num1中间位置为i，那么考虑两个数组merge起来的情况，若num1[i] &gt; num2[k-i]，则第k大会出现在num1[:i]和num2[k-i:]中，否则则会出现在num1[i:]和num2[:k-i]中。递归求解即可。 5. Longest Palindromic Substring马拉车算法 6. ZigZag Conversion找规律即可，从前往后扫，rows[(num - i % num) % numRows].append(s[i]) 7. Reverse Integerwhile不停模即可 8. String to Integer (atoi)细心即可 9. Palindrome Number负数则false，整数则reverse然后判断是否相等 10. Regular Expression Matching最基础的正则表达式实现。（python的话import re;return re.match(‘^’+p+’$’,s) != None 11. Container With Most Water对于$ih[i]。因此，可以建立vector，一个从前往后建议单调升的序列，一个从后往前，最终O(n^2)扫一遍即可（处理过之后实际复杂度比n^2小很多） 12. Integer to Roman细心即可，可以用来学习罗马数字。。 13. Roman to Integer同12 14. Longest Common Prefix以第一个字符串为基准匹配即可 15. 3Sum排序，枚举两个数，二分查找第三个数，注意不要找到重复的 16. 3Sum Closest基本同15 17. Letter Combinations of a Phone Number深搜枚举 18. 4Sum 可以同3Sum。 排序后，n^2枚举前两个数，接着两个指针i, j，一个从前往后，一个从后往前，枚举剩下两个数，总时间复杂度为O(n^3) 19. Remove Nth Node From End of List扫一遍知道总节点数，扫第二遍删除 20. Valid Parentheses经典栈应用题目 21. Merge Two Sorted Lists方法跟普通数组merge一样 22. Generate Parentheses深搜枚举 23. Merge k Sorted Lists同21 24. Swap Nodes in Pairs细心推导即可python写法1ptr.next, ptr.next.next,ptr.next.next.next = ptr.next.next,ptr.next,ptr.next.next.next 26. Remove Duplicates from Sorted Array扫一遍 27. Remove Element扫一遍 28. Implement strStr()kmp算法 29. Divide Two Integers见之前博客 http://blog.csdn.net/nevermorezjh/article/details/52614583 30. Substring with Concatenation of All Words因为所有words的长度都是一样的，所以可以不停枚举，贪心即可 31. Next Permutation基础找到下一个排列的操作，找到最后一个位置j，j到最后都是倒序，如15432，找到5432，那下一个就是21345，后面完全升序 32. Longest Valid Parentheses同样用栈进行操作，注意到当有一个右括号的时候，即出栈的时候，必然就会产生一个有效的序列，因此只需要按顺序统计即可。 33. Search in Rotated Sorted Array没有重复的数字，rotate一个数组的例子：0 1 2 3 4 5 -&gt; 4 5 0 1 2 3，那么进行一次二分搜索将会将target定位到rotate分得的两个部分之一，再进行一个二分搜索即可。 34. Search for a Rangelower_bound upper_bound 35. Search Insert Positionlower_bound 36. Valid Sudoku数独规则 37. Sudoku Solver深搜回溯，试解 38. Count and Say模拟一遍即可 39. Combination Sum深搜，枚举组合，因为数组本身没有重复，所以要不出现重复只要按顺序枚举即可。而全都是整数，所以要target大于等于零，因为可以使用重复数字，所以可以从当前数字开始递归求解。 40. Combination Sum II跟39几乎一样，因为不能用重复的数字，所以递归的时候要从下一个数字开始 41. First Missing Positive见之前的博客 42. Trapping Rain Water栈维护，之前博客也有 43. Multiply Strings高精度乘法 44. Wildcard Matching两个指针分别扫，遇到?可以直接指针向前一步，对于*要记录当前位置，注意回溯，注意这里可以贪心，取最新的*，(相当于贪婪模式的正则表达式？) 45. Jump Game II宽搜 46. Permutations深搜，全排列 47. Permutations II深搜，要不能重复，只需实现排序，深搜从不一样的数字继续递归 48. Rotate Image1234567void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; for (unsigned int i=0; i&lt;matrix.size(); i++) for (unsigned int j=0; j&lt;i; j++) swap(matrix[i][j], matrix[j][i]); for (auto&amp; row: matrix) reverse(row.begin(), row.end()); &#125; 49. Group Anagrams按排序后的字符串，进行map映射即可（hash），结果需要再排序一遍 50. Pow(x, n)快速幂 51. N-Queens与8妃问题一样，深搜 52. N-Queens II方法跟51一样，得到解的时候记录一下即可 53. Maximum Subarray最大子序列问题，贪心扫一遍（一维dp？），dp = max(dp+nums[i],nums[i]); 54. Spiral Matrix简单模拟 55. Jump Game宽搜 58. Length of Last Word扫一遍，遇到空格清零 59. Spiral Matrix II还是简单模拟 60. Permutation Sequence要求第k个排列，因为n个数一共有n!种排列，所以可以根据k的大小逐步从第一个数字往最后一个推算 61. Rotate List链表的基本操作 62. Unique Paths简单dp，dp[i][j] = dp[i-1][j] + dp[i][j-1] 63. Unique Paths II跟62一样，对于障碍物不计算即可 64. Minimum Path Sum深搜 65. Valid Number细心，注意边界情况 66. Plus One可以当作高精度加法来做 67. Add Binary2进制高精度加法 69. Sqrt(x)见之前博客 70. Climbing Stairs斐波那契数 71. Simplify Path模拟，细心，注意边界情况 72. Edit Distance编辑距离，简单dp 73. Set Matrix Zeroes用set来维护需要清零的行和列，即可满足空间和时间复杂度要求 74. Search a 2D Matrix竖着找lower_bound，然后横着二分 75. Sort Colors桶排序 76. Minimum Window Substring根据字母ascii码值（hash）来维护一个出现次数的数组，贪心 77. Combinations深搜回溯 78. Subsets状态压缩 79. Word Search深搜回溯 80. Remove Duplicates from Sorted Array II扫一遍即可 81. Search in Rotated Sorted Array II解法跟1类似，不过为了排除重复，第一次二分查找要取upper_bound 82. Remove Duplicates from Sorted List II简单链表操作 83. Remove Duplicates from Sorted List简单链表操作 84. Largest Rectangle in Histogram使用栈来维护，注意的细节是最好在最开头加上0比较轻松 85. Maximal Rectangle按行解决，利用84题 86. Partition List扫两遍 88. Merge Sorted Arraymerge数组而已 89. Gray Code格雷码学习 90. Subsets II深搜 91. Decode Ways动态规划，注意不合法的情况 92. Reverse Linked List II链表操作，搞清楚变换规律即可，要求是O(1)空间和扫一遍完成 93. Restore IP Addresses深搜回溯 94. Binary Tree Inorder Traversal中序遍历 95. Unique Binary Search Trees II递归求解，枚举根是第i个元素，用[0:i)组成左子树，[i+1:)组成右子树 96. Unique Binary Search Trees95简单版，只求总数目 97. Interleaving Strings1[i] == s2[j]时递归深搜，剪枝方面对字符串进行哈希，防止重复搜索 98. Validate Binary Search Tree检查中序遍历结果 99. Recover Binary Search Tree根据中序遍历结果，找到错误的位置，交换一下即可 100. Same Tree根、左子树、右子树，递归判断 101. Symmetric Tree实际上是，左子树的左子树等于右子树的右子树，左子树的右子树等于右子树的左子树，递归判断 102. Binary Tree Level Order Traversal层序遍历，宽搜 103. Binary Tree Zigzag Level Order Traversal层序遍历，奇数层翻转一下 104. Maximum Depth of Binary Tree递归解 105. Construct Binary Tree from Preorder and Inorder Traversal前序的第一个为根，找到中序与根相同的位置，分左子树，右子树递归求解 106. Construct Binary Tree from Inorder and Postorder Traversal后序最后一个为根，找到中序与根相同的位置，分左子树，右子树递归求解 107. Binary Tree Level Order Traversal IIreverse一遍102 108. Convert Sorted Array to Binary Search Tree根为中间点，分左子树，右子树递归求解 109. Convert Sorted List to Binary Search Treelist变成vector，用108解 110. Balanced Binary Tree根据平衡二叉树性质（子树高度，大小关系），递归判断求解 111. Minimum Depth of Binary Tree递归求解 112. Path Sum深搜 113. Path Sum II深搜，耗点空间，带上已搜到的数一起递归 114. Flatten Binary Tree to Linked List前序遍历 116. Populating Next Right Pointers in Each Node宽搜 118. Pascal’s Triangle帕斯卡三角形的计算（组合数） 119. Pascal’s Triangle II得到某一行帕斯卡三角形（组合数） 120. Triangle从上往下动态规划，注意因为可以从当行转移，因此对于同一行要进行两次转移，保证正确，即一次只能上往下和向右，一次只能上往下和向左 121. Best Time to Buy and Sell Stock一维dp 122. Best Time to Buy and Sell Stock II贪心 124. Binary Tree Maximum Path Sum递归求解，分两种情况，一种是包含根求和，一种是不包含根 125. Valid Palindrome回文串判断，不管空格和标点符号和大小写 126. Word Ladder II建字典树深搜 127. Word Ladder深搜即可 128. Longest Consecutive Sequenceset来维护，没插入一个数，就往前往后，看看相邻的数在不在，进而得到最优解 129. Sum Root to Leaf Numbers直接深搜 130. Surrounded Regions对圆圈进行宽搜 131. Palindrome Partitioning分治递归求解，若s[:i]是回文串，那么就对s[i+1:]进行递归求解，与s[i+1:]的解串起来即可 132. Palindrome Partitioning II马拉车算法找出最长的回文字串，然后再分治求解其它部分 133. Clone Graph建立label-&gt;node映射map，从根节点开始递归求解 134. Gas Station只要补给大于消耗就能保证能走完全程，要找正确的起点，则贪心找到能一直走不会没有补给的时候就行了，即从头开始扫一遍即可。 135. Candy正着扫一遍保证从前往后符合条件，然后反着扫一遍保证从后往前符合条件，最后取两者最大值即可。 136. Single Number扫一遍，异或一遍即可 137. Single Number II同136，位运算 139. Word Break深搜枚举 140. Word Break II基本同139 151. Reverse Words in a String扫一遍找到每个单词然后翻转即可 152. Maximum Product Subarray一维dp，计算一个正的最大，一个负的最大（最小） 153. Find Minimum in Rotated Sorted Arrayupper_bound的二分搜索 154. Find Minimum in Rotated Sorted Array II分治求解（分治也可以解153） 155. Min Stack用两个栈模拟 160. Intersection of Two Linked Lists多次扫，得到交点的位置 162. Find Peak Element二分搜索策略，根据arr[l], arr[mid], arr[r]大小关系，即可知道哪部分会有peak 164. Maximum Gap利用桶排序的思想，每个桶代表一个范围，设置该桶中的最大值和最小值。 165. Compare Version Numbers直接字符串流输入整数和小数部分 166. Fraction to Recurring Decimal分数转循环小数，除法部分跟高精度除法类似，关键是找到循环节，其实暴力起来除的位数高到一定就可以找到了，印象中可以证明循环到一定次数就能保证（想起某次4+2） 168. Excel Sheet Column Title相当于10进制转26进制 169. Majority Element因为某个数大于总数一半，所以设一个计数器cnt，按顺序扫一遍的过程，cnt为0时换当前扫到的数字，遇到相同则+1，不同则-1，为0时再换，遇到出现最多的那个数的时候，直到扫完必然还是它为结果 171. Excel Sheet Column Number同168 172. Factorial Trailing Zeroes算2，5个数 173. Binary Search Tree Iterator中序遍历预处理一次 179. Largest Number排序，设置的比较函数为对数字a，b，将其转为字符串sa，sb，若sa+sb的字典序大于sb+sa的，那sa大于sb，否则，相反 187. Repeated DNA Sequences因为最长不超过10个字符，又只有ACGT，所以暴力用set都行。。 189. Rotate Array难点在O(n)时间，O(1)空间，没想到。。 190. Reverse Bits跟10进制一样的 191. Number of 1 Bits简单位运算 198. House RobberO(n)的dp，分偷和不偷两种情况 199. Binary Tree Right Side View宽搜，因为宽搜是一层一层从左到右的，所以注意判断转入下一层的时候即可 200. Number of Islands宽搜，深搜都行 201. Bitwise AND of Numbers Range位运算，找到m，n二进制中相同的前几位 202. Happy Number模拟递归着就好 203. Remove Linked List Elements链表基本操作 204. Count Primes线性筛素数 205. Isomorphic Stringsmap映射即可 207. Course Schedule拓扑排序，从入度为0的节点开始 208. Implement Trie (Prefix Tree)写个Trie树 209. Minimum Size Subarray Sum前缀和+二分搜索 210. Course Schedule II拓扑排序 211. Add and Search Word - Data structure design字典树，遇到.就深搜 212. Word Search II字典树 220. Contains Duplicate III每个往后找就行，基本不用怎么优化。。 233. Number of Digit One数位dp的思路，可以优化到O(1)空间一重循环解决 236. Lowest Common Ancestor of a Binary Tree题目暴露了LCA，这里也可以直接递归求解 238. Product of Array Except Self两边夹击 239. Sliding Window Maximum线段树维护（好像也可以单调队列维护 240. Search a 2D Matrix II横竖一起二分搜索 241. Different Ways to Add Parentheses分治算法 260. Single Number III位运算找出两个数的异或，然后找到它们不同的一个位置，然后根据那一位分开异或 264. Ugly Number II暴力用set，不过时间有点长。。虽然过了 273. Integer to English Words细心，边际情况要考虑周到 274. H-Index排序一遍，再扫一遍即可 275. H-Index II二分查找 287. Find the Duplicate Number见之前的博客 295. Find Median from Data Stream大小顶堆来动态维护 304. Range Sum Query 2D - Immutable二维的前缀和（速度垫底了。。） 307. Range Sum Query - MutableBIT维护 312. Burst Balloons分治+二维dpd[start][end] = max(d[start][end], d[start][k - 1] + d[k + 1][end] + nums[start - 1] nums[k] nums[end + 1]); 315. Count of Smaller Numbers After SelfBIT维护，最大数字不会很大 319. Bulb Switcher数学，扫一遍，有多少个i*i&lt;=n 327. Count of Range Sum二分搜索优化 329. Longest Increasing Path in a Matrix构图，只能从低数字走向高数字，然后拓扑排序，找最长路径 392. Is Subsequence两个指针一起往后扫 407. Trapping Rain Water II从外围往里面宽搜，从最低的位置开始扩张，实际上是找islands的加强版 410. Split Array Largest Sum二分答案，看是否满足 474. Ones and Zeroes01背包问题，dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1); 477. Total Hamming Distance按位扫一遍即可","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"leetcode-995","slug":"leetcode-995","date":"2019-03-19T02:23:45.000Z","updated":"2019-03-19T02:33:54.998Z","comments":true,"path":"2019/03/19/leetcode-995/","link":"","permalink":"http://yoursite.com/2019/03/19/leetcode-995/","excerpt":"","text":"题意就是给你一个01数组，还有一个K，要求一次翻转要翻转K个连续的01值，问最少翻多少次能够使得整个数组变成全部都是1的。 跟灯泡问题类似，解决的思路很简单，就是从一端开始，如果遍历到0，那么必须从它开始翻转K的01值，首先因为该处是0，所以必须要进行翻转操作，而如果在它之前翻转，那么它前面的1值都也会被翻转，破坏了前面的结构，因此必须从遍历到的0开始，往后翻转K个位置，看最终能够将整个数组翻转成为目标数组（就算目的不是要求数组数字全部都为1，应该也是一样的思路）。那么就有一个比较naive的做法，就是将这个过程模拟，然而复杂度是$O(n^2)$的，题目会卡一下…虽然运气好也能过。 naive代码如下 1234567891011121314151617181920212223class Solution &#123;public: int minKBitFlips(vector&lt;int&gt;&amp; A, int K) &#123; int size = A.size(); int cnt = 0; for (int i=0;i&lt;=size-K;++i) &#123; if (A[i] == 0) &#123; for (int j=i+K-1;j&gt;=i;--j) &#123; A[j] = 1-A[j]; &#125; cnt++; &#125; &#125; bool ok = true; for (int i=size-K;i&lt;size;++i) &#123; if (A[i] == 0) &#123; ok = false; &#125; &#125; return ok?cnt:-1; &#125;&#125;; 而考虑到，翻转数字的过程中，对于长度为K的数组，很可能会重复翻转，这是不必要的开销，因为$O(n^2)$复杂度的来源就是多了一重重复翻转数字的过程，因此可以建立一个标记数组，标记翻转的终点，超过了终点，也就意味着不用继续翻转，而对于遍历过程中的多个遍历翻转片段，所以整个过程是翻转的肯定和否定的过程，新开一个数组，优化复杂度为$O(n)$ 1234567891011121314151617181920212223class Solution &#123;public: int minKBitFlips(vector&lt;int&gt;&amp; A, int K) &#123; int size = A.size(); vector&lt;bool&gt; flip(size+1, 0); int cnt = 0; bool flipping = 0; for (int i=0;i&lt;size;++i) &#123; flipping = (flipping ^ flip[i]); if ((A[i] ^ flipping) == 0) &#123; if (i + K &gt; size) &#123; return -1; &#125; else &#123; flipping = 1-flipping; flip[i+K] = 1 - flip[i+K]; cnt++; &#125; &#125; &#125; return cnt; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"effective-C++(6)","slug":"effective-C-6","date":"2019-03-18T06:17:27.000Z","updated":"2019-03-19T02:55:54.055Z","comments":true,"path":"2019/03/18/effective-C-6/","link":"","permalink":"http://yoursite.com/2019/03/18/effective-C-6/","excerpt":"","text":"条款32：确定你的public继承塑模出is-a关系public继承中表示类之间的关系是严格的is-a关系，代表基类中所有的函数都适用于继承类，如penguin继承于bird，如果需求中bird需要fly，那么直接public继承于带fly函数的bird是不合适的，同理还有square继承于带单独实现调整width的rectangle也是不合适的，前者的话可以考虑单独的bird，区分flyingbird和penguin这样不飞的bird。所以实际上是否public继承也是取决于需求和业务场景，并需要及时调整。 条款33：避免遮掩继承而来的名称C++的作用域而言，如果一个作用域中找不到合适的函数或者变量，都会往外一层的作用域中寻找。然而，实际上类中并不会这样做，尽管是public继承，在继承类中如果实现了基类某个函数的其他版本（就算是参数不一样），也会把基类的函数覆盖，有时候本以为只是一种重载，添加其他函数来使用，实际上是一种覆盖关系，可能会造成调用过程的报错。解决方法可以在继承类中使用using Base::func，向编译器要求提供某个函数的版本，而当要求的时候不需要指定参数，而是直接把基类的所有版本函数搬过来进行使用，参数相同的话，那就是重载覆盖。 1234567891011121314151617181920212223class Base &#123;public: void func(int x) &#123; cout&lt;&lt;\"Base: \"&lt;&lt;x&lt;&lt;endl; &#125; void func() &#123; cout&lt;&lt;\"Base\"&lt;&lt;endl; &#125; &#125;;class Derived: public Base &#123;public: using Base::func; void func(int x) &#123; cout&lt;&lt;\"Derived: \"&lt;&lt;x&lt;&lt;endl; &#125;&#125;;int main() &#123; Derived x; x.func(10); return 0;&#125; 条款34：区分接口继承和实现继承对于基类的virtual函数，设置成pure virtual往往是比较适合的做法，因为能够防止继承类忘记实现对应的实现而错误地调用了基类的default实现，当然如果确定调用的话，设计成实现继承也无妨。 条款35：考虑virtual函数以外的其他选择当设计基类的某个函数涉及到策略等继承类需要各自实现它们自己的计算方法的时候，不仅仅可以考虑virtual函数方法来实现，还有以下多种方法。 Non-Virtual Interface手法，倾向于将所有的virtual函数定义成private类型的，使用的时候通过同一个public non-virtual函数来进行调用，对客户使用比较友好。但是这种情况下，如果继承类要调用基类型的private virtual function则有麻烦，需要将private的函数改成protected的，来保证继承类能够使用。 Strategy模式，Strategy模式是一种经典的设计模式，最直接的做法就是将virtual函数转化成需要输入函数指针的函数，对于不同的继承类，实现不同的函数，并以指针的方式进行传参和调用，实现了策略和本体的分离，灵活性很强，并且不同的继承类实体还能有不一样的计算函数（传的函数指针不一样即可），并且在运行期可以选择不同的函数指针，调整计算方法。当然这种方法因为不在类中，因此如果要访问类中的元素可能还需要声明为friend函数，但是这种方法也会弱化类的封装，当然用member函数来调用也不是不可以。 更高级一点的做法去实现Strategy模式就是通过类提高封装性，如下面的代码 1234567891011121314151617class GameCharacter; // forward declarationclass HealthCalcFunc &#123;public: ... virtual int calc(const GameCharacter &amp;gc) const &#123; ... &#125; ...&#125;;HealthCalcFunc defaultHeathCalc;class GameCharacter &#123;public: explicit GameCharacter(HealthCalcFunc *phcf = &amp;defaultHealthCalc): pHealthCalc(phcf) &#123;&#125; int healthValue() const &#123; return pHealthCalc-&gt;calc(*this); &#125; ...private: HealthCalcFunc* pHealthCalc;&#125;; 条款36：绝不重新定义继承而来的non-virtual函数如果你是public继承，那么对于non-virtual函数没有理由在一个is-a基类的继承类重新定义它的实现。而且对于non-virtual函数，函数调用时非动态绑定的，使用多态很容易调用错误的函数。 条款37：绝不重新定义继承而来的缺省参数值因为函数的缺省参数值是静态绑定的，就算你是virtual函数，你在继承类重新定义了缺省参数值，使用基类的指针来调用，其缺省参数值必然是基类的参数值。 123456789101112131415161718192021222324252627282930313233class Shape &#123;public: enum ShapeColor&#123;Red, Green, Blue&#125;; virtual void draw(ShapeColor color = Red) const = 0;&#125;;class Rectangle: public Shape &#123;public: virtual void draw(ShapeColor color = Green) const &#123; cout&lt;&lt;\"Rectangle: \"&lt;&lt;color&lt;&lt;endl; &#125;&#125;;class Circle: public Shape &#123;public: virtual void draw(ShapeColor color) const &#123; cout&lt;&lt;\"Circle: \"&lt;&lt;color&lt;&lt;endl; &#125;&#125;;int main() &#123; Shape *ps; Shape *pc = new Circle; Shape *pr = new Rectangle; ps = pc; ps = pr; pc-&gt;draw(Shape::Red); pr-&gt;draw(Shape::Red); pr-&gt;draw(); return 0;&#125; 条款38：通过复合塑模出has-a或“根据某物实现出”在应用域上，复合意味着has-a，在实现域上，复合意味着is-implemented-in-terms-of。 条款39：明智而审慎地使用private继承private继承跟public继承不同，没有办法做到动态调用，因为private继承会把所有基类成员函数转换成private，无法保证函数还能够public调用。另外，private继承能保证的是继承类能够访问到基类的public和protected成员，而private成员将无法访问。 实际上，private继承意味着is-implemented-in-terms-of，跟复合一样，然而它的级别往往比复合要低。好处的地方是，相比起复合来说，不仅能访问public的，更是多了可以访问protected的成员，并且virtual函数也能继承过来，并override它，否则一般而言还是使用复合的处理方法更加合适。还有一个优点是empty base最优化。 条款40：明智而审慎地使用多重继承多重继承上就体现了virtual继承的重要性，但是virtual继承同时也会带来大小，速度，初始化复杂度等成本，如果virtual base classes不带任何数据，那么将是最具实用价值的情况。 用法如下，可以看到dataA的地址是一样的，也就是指向了同样的数据位置，而如果不在B和C之间安排virtual继承的话，D中的数据是没有办法优化去除ambiguous的，因为虚继承的实现机制是在基类（B和C）中建立虚表（vbptr），来指向同样的位置，在D中才安排virtual继承是没有效果的。 1234567891011121314151617181920212223242526class A &#123;public: int dataA;&#125;;class B: virtual public A&#123;public: int dataB;&#125;;class C: virtual public A &#123;public: int dataC;&#125;;class D: public B, public C &#123;public: int dataD;&#125;;int main() &#123; D d; cout&lt;&lt;(&amp;d.dataA)&lt;&lt;endl; cout&lt;&lt;(&amp;(d.B::dataA))&lt;&lt;endl; cout&lt;&lt;(&amp;(d.C::dataA))&lt;&lt;endl;&#125; 多重继承也有正当用途，如“public继承某个interface class”和“private继承某个协助实现的class”的两相结合，但是场景还是相对较少。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"leetcode-975","slug":"leetcode-975","date":"2019-03-12T07:49:15.000Z","updated":"2019-03-12T08:20:08.411Z","comments":true,"path":"2019/03/12/leetcode-975/","link":"","permalink":"http://yoursite.com/2019/03/12/leetcode-975/","excerpt":"","text":"题意很有意思，定义一个操作是奇偶跳跃，第奇数次跳跃，就必须跳往大于等于自己的，并且是往前最近的一个位置，而第偶数次跳跃，就要跳往小于等于自己的，并且是往前最近的一个位置。问，可以从任意一个位置启动，有多少个可以启动到达到最后一个位置的位置。 首先，这是跳跃相关的问题，因此有dp的思路，从一段的跳跃，逐渐扩展到整一段的跳跃。而这题，因为是跳跃到前面自己最靠近的位置，因此必须从后往前dp。如果从前往后dp，会发现后面加入的位置，可能成为前面的点更应该跳跃到的位置，从而导致了dp没有递推性，公式不成立，而从后往前dp就不会有这样的问题。 而第二个问题，就是如何找到自己最靠近的数，也就是跳跃点的寻找，naive的做法自然是$O(n)$去寻找跳跃点，dp扩展的过程中，找新加入位置的跳跃点，然后根据前面dp到的信息，判断它要跳跃的点能不能跳跃到最后一个位置，实现dp，那么有没有更加高效的方法呢？ 有两种，第一种是dp的过程中，维护这样的排序序列，使用堆来进行优化，来找到最接近的位置，而stl库里面正好有map来帮助维护这个结构，接下来就是考察map的使用方法了（这道题考察的还挺全面的，所以记录一下）。 对map来说，它的迭代器是双向的，官方文档描述它的iterator是a bidirectional iterator to value_type（某些博客里没写对），因此可以很方便地找到目标前后的大概位置。 map还有lower_bound和upper_bound函数，顺便学习了一下这两个函数的具体使用场景和方法（其实一直我只会用lower_bound），而map也有专用的两个bound的接口可以直接使用，lower_bound就是找到大于等于自己这个数的最小的索引位置，而upper_bound就是找到大于自己的最小的索引位置（理解应该没问题），所以在这题里面就很简单了，使用lower_bound找到离自己最近的大于等于自己的那个位置，upper_bound加往前的迭代器找到离自己最近的小于等于自己的那个位置，完成$O(log(n))$的查找和维护。 最后dp的思路也很简单，从最后一个点的前一个点开始，看每个点的奇偶跳跃能不能到达最后一个点只要知道它将要跳跃的点能不能到达最后一个点，因为要知道从那一点开始能不能到达最后一个点，也就是第一次跳跃，所以如果它跳往大于等于它的那个位置能够偶数跳跃到最后一个点，那就代表它能够到达最后一个点，而它要经过偶数跳跃调到最后一个点，那它偶数跳跃到的那个点必须能奇数跳跃到最后一个点，正好是$O(n)$的dp，最终复杂度是$O(nlog(n))$ AC代码如下： 123456789101112131415161718192021class Solution &#123;public: int oddEvenJumps(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); vector&lt;bool&gt; even(n, false), odd(n, false); map&lt;int, int&gt; mp; int ans = 1; mp[A[n-1]] = n-1; even[n-1] = odd[n-1] = true; for (int i=n-2;i&gt;=0;--i) &#123; int val = A[i]; auto oddJump = mp.lower_bound(val); auto evenJump = mp.upper_bound(val); if (oddJump != mp.end()) odd[i] = even[oddJump-&gt;second]; if (evenJump != mp.begin()) even[i] = odd[(--evenJump)-&gt;second]; if (odd[i]) ++ans; mp[val] = i; &#125; return ans; &#125;&#125;; 第二种方法就是用到上一篇提到的单调栈结构（应该也是本题的出题目的，毕竟标记了stack的标签）。关键就是如何使用单调栈来获取点的跳跃位置，回想上一题就会发现思路其实几乎是一样的，奇数跳跃就是从小到大排好序，大小一样就按index排序，栈中维护的单调性是index的单调性，当它遇到了index比它后的，那么就代表它将要跳往那一个点了，因为刚好比它大，而且index是最小的，扫一遍即可完成，而排序是$O(nlog(n))$的复杂度。偶数跳跃的思路也一样。结合最后的$O(n)$dp，其实总复杂度也是$O(nlog(n))$，而因为这是一下子排序好了的，因此比上面的维护过程会快一点。 而此处也认识了一个新的知识点，就是vector中用emplace_back的速度是优于push_back的，主要原因是前者只需要一次构造函数，后者还可能还会多一次拷贝构造函数，开销稍微大一点。 AC代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960bool cmp1(const pair&lt;int, int&gt; &amp;lhs, pair&lt;int, int&gt; &amp;rhs) &#123; return lhs.first &gt; rhs.first || (lhs.first == rhs.first &amp;&amp; lhs.second &lt; rhs.second);&#125;bool cmp2(const pair&lt;int, int&gt; &amp;lhs, pair&lt;int, int&gt; &amp;rhs) &#123; return lhs.first &lt; rhs.first || (lhs.first == rhs.first &amp;&amp; lhs.second &lt; rhs.second);&#125;class Solution &#123;public: int oddEvenJumps(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); vector&lt;pair&lt;int, int&gt;&gt; vec; for (int i=0;i&lt;n;++i) &#123; vec.emplace_back(A[i], i); &#125; sort(vec.begin(), vec.end(), cmp2); vector&lt;int&gt; oddNext(n, -1); stack&lt;pair&lt;int, int&gt;&gt; st; st.push(vec[0]); for (int i=1;i&lt;n;++i) &#123; auto p = vec[i]; while (!st.empty() &amp;&amp; st.top().second &lt; p.second) &#123; oddNext[st.top().second] = p.second; st.pop(); &#125; st.push(p); &#125; sort(vec.begin(), vec.end(), cmp1); vector&lt;int&gt; evenNext(n, -1); stack&lt;pair&lt;int, int&gt;&gt;().swap(st); st.push(vec[0]); for (int i=1;i&lt;n;++i) &#123; auto p = vec[i]; while (!st.empty() &amp;&amp; st.top().second &lt; p.second) &#123; evenNext[st.top().second] = p.second; st.pop(); &#125; st.push(p); &#125; int ans = 1; vector&lt;bool&gt; oddJump(n, false), evenJump(n, false); oddJump[n-1] = evenJump[n-1] = 1; for (int i=n-2;i&gt;=0;--i) &#123; int evennext = evenNext[i], oddnext = oddNext[i]; if (evennext != -1 &amp;&amp; oddJump[evennext]) &#123; evenJump[i] = true; &#125; if (oddnext != -1 &amp;&amp; evenJump[oddnext]) &#123; ans += 1; oddJump[i] = true; &#125; &#125; return ans; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"effective-C++(5)","slug":"effective-C-5","date":"2019-03-11T12:06:44.000Z","updated":"2019-03-11T12:57:07.957Z","comments":true,"path":"2019/03/11/effective-C-5/","link":"","permalink":"http://yoursite.com/2019/03/11/effective-C-5/","excerpt":"","text":"条款26：尽可能延后变量定义式的出现时间延后变量定义的时间考虑的点有两个，一个是防止变量没有用上，就陷入了异常当中，导致变量构造和析构的不必要开销，另一个则是出于RAII的考虑，不应当无内容地构造一个变量，需要用到的时候再创建出来即可，代码优美，可读性高。 还有一个考虑的场景是循环内的变量，应该在循环内需要用到再构造还是在循环外先构造好，减少析构函数的开销，其实根据条款来说自然是倾向于在循环内构造，因为循环外构造会遇到的问题就是变量的作用域变大了，不够美观和安全的同时，也出现了没有凭空构造对象的状况（个人觉得，这种代码也有点不够美观…），当然，如果是在效率要求比较高的代码环境下，在循环外定义还是有一定的意义的，而且变量作用域的问题也可以直接添加一个大括号作为scope来解决。 条款27：尽量少做转型操作C风格的转型动作也成为旧式转型，主要如下 12(T)expression;T(expression); 而C++则提供多了其余四种转型类型 1234const_cast&lt;T&gt;(expression);dynamic_cast&lt;T&gt;(expression);reinterpret_cast&lt;T&gt;(expression);static_cast&lt;T&gt;(expression); C++中运用新型转型的意义有两个，一个是代码辨识度高，容易区别出哪些地方出现了类型系统问题，第二个则是各类型动作的目标窄化，有利于编译器和人为判断出出错位置。 对于C风格的旧型转型，作者更加倾向于只在需要explicit构造的函数中使用，其余地方均使用C++的转型类型。 而下面有几个需要注意的问题。 第一个是对于某些平台上（如嵌入式平台），继承类的对象指针跟基类的对象指针有一定的偏移量，但是某些平台上（如pc）则没有这种偏移量（undefined behavior）。如下面的代码 1234class Base &#123;...&#125;class Derived: public Base &#123;...&#125;;Derived d;Base *pb = &amp;d; 此时出现了一定的类型转换，而对于习惯偏移量的程序员来说，如果过于对自己过于自信，直接添加偏移量来获得Derived类的指针位置，则必然导致错误。 第二个则是自作聪明地写出了似是而非的代码。如下面的代码中，static_cast&lt;Base&gt;(*this).incAndGetVal();，看似调用的是基类型的函数，但是如果深入到构造的过程就会发现，类型转换的过程中出现了拷贝构造行为，也就是说类型转换过程包含了拷贝构造的过程，调用的函数也是调用拷贝的对象的函数，那么如果程序员这时候以为自己调用的是本对象的成员函数，以为成功对本对象的成员进行了操作，那么则会导致比较难以察觉的错误，正确的方法则是直接调用基类域中的函数即可Base::incAndGetVal()。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Base &#123;private: int val;public: Base(int v): val(v) &#123; cout&lt;&lt;\"Base constructor\"&lt;&lt;endl; &#125; Base(const Base &amp;rhs): val(rhs.val) &#123; cout&lt;&lt;\"Base copy constructor\"&lt;&lt;endl; &#125; virtual int incAndGetVal() &#123; val++; return val; &#125; virtual ~Base() &#123; cout&lt;&lt;\"Base deconstructor\"&lt;&lt;endl; &#125;&#125;;class Derive: private Base &#123;public: Derive(int v): Base(v) &#123; cout&lt;&lt;\"Derived constructor\"&lt;&lt;endl; &#125; Derive(const Derive &amp;rhs): Base(rhs) &#123; cout&lt;&lt;\"Derived copy constructor\"&lt;&lt;endl; &#125; virtual int incAndGetVal() &#123; return static_cast&lt;Base&gt;(*this).incAndGetVal(); &#125; ~Derive() &#123; cout&lt;&lt;\"Derived deconstructor\"&lt;&lt;endl; &#125;&#125;;int main() &#123; Derive test(10); cout&lt;&lt;test.incAndGetVal()&lt;&lt;endl; cout&lt;&lt;test.incAndGetVal()&lt;&lt;endl; return 0;&#125; 还有就是注意dynamic_cast的调用，因为这种调用的成本很高，会在运行的过程中反复调用strcmp函数，来找到你要转换成的继承对象，进而通过基类指针调用到你想调用的继承类对象的成员函数。如果可以，把变量直接声明成对应的继承类型即可，减少了运行期的开销。 条款28：避免返回handles指向对象内部部分为了提高类的封装性，自然是要避免返回handles（包括references，指针，迭代器等）指向对象内部，并且帮助const成员对象的行为像个const（记得什么时候要返回const类型），并防止dangling handles（因为返回对象会马上被析构，指针指向它自然就dangling了）。 条款29：为“异常安全”而努力是值得的异常安全需要保证两个方面，第一个是不泄露任何资源（抛出异常的时候保证所有资源能够被正常析构），第二个则是不允许数据破坏（抛出异常的时候要保证数据操作正确，不受异常影响）。 三个保证，基本承诺（没有对象数据被损坏），强烈保证（跟调用出现异常的函数之前一模一样），不抛掷保证（nothrow）。 下面是简单的copy and swap策略介绍。 123456789101112131415161718struct PMImpl &#123; shared_ptr&lt;Image&gt; bgImage; int imageChanges;&#125;;class PrettyMenu &#123;private: Mutex mutex; shared_ptr&lt;PMImpl&gt; pImpl;&#125;;void PrettyMenu::changeBackground(std::istream&amp; imgSrc) &#123; using std::swap; Lock ml(&amp;mutex); shared_ptr&lt;PMImpl&gt; pNew(new PMImpl(*pImpl)); pNew-&gt;bgImage.reset(new Image(imgSrc)); ++pNew-&gt;bgImage.imageChanges; swap(pImpl, pNew);&#125; 这里主要防止了构造新的pImpl的过程中抛出异常，导致原来的pImpl的数据出现问题，而且作为指针，swap的开销也并不高，当然这种策略的应用范围也有一定的条件限制，因此还需要特殊情况特殊分析。 条款30：透彻了解inlining的里里外外inline函数背后提高效率的优化概念就是，将每个调用的函数，都以函数的本体来代替，那么如果这样的函数过于频繁地被多处调用，那么将会导致代码膨胀的问题。考虑操作系统的概念，操作系统都会把要运行的代码放到一块内存当中，并采用分页的管理方法，那么如果代码过于膨胀，这样的inline函数会导致程序执行的过程中进行频繁的换页行为，这些损失可以说是得不偿失的。 而隐式inline的地方更多是在类当中，如果函数直接在类中的声明中实现了，像我上面的Base一样，将会默认是inline函数，而要知道，编译器是会为类生成构造函数，析构函数等函数的，如果直接在类中实现或是不实现，都会导致过多的inline函数，产生了不易发现的效率影响。 另外，inline函数一般也无法取得函数指针（因为编译器只是按代码段来看待）。所以需要函数指针时，编译器可能会拒绝inline。 条款31：将文件间的编译依存关系降至最低善用handle classes和interface classes。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"effective-C++(4)","slug":"effective-C-4","date":"2019-03-05T03:25:19.000Z","updated":"2019-03-05T06:52:05.715Z","comments":true,"path":"2019/03/05/effective-C-4/","link":"","permalink":"http://yoursite.com/2019/03/05/effective-C-4/","excerpt":"","text":"条款18：让接口容易被正确使用，不易被误用本条款精髓在一个先发制人，也就是说，接口设计者会对接口进行特别的设计，来保证接口使用者按照一定规则来使用接口，避免误用，提高可读性，提高bug定位的速度。 举个例子，如下面的日期类构造函数。 123456class Date &#123;public: Date(int month, int day, int year);&#125;;Date d(5, 3, 1995); 上述代码中，使用者或者reviewer不一定能发现是5月3日还是3月5日，甚至出bug的时候也不容易发现这小细节（虽然是可以在构造函数中构建日志…）但是更直接地提高可读性的方法是增加识别的wrapper，开销不大，但是可读性大大增加了。 12345678910111213141516171819struct Day &#123; explicit Day(int d): val(d) &#123; &#125; // 注意explicit int val&#125;;struct Month &#123; explicit Month(int d): val(d) &#123; &#125; int val&#125;;struct Year &#123; explicit Year(int d): val(d) &#123; &#125; int val&#125;;class Date &#123;public: Date(const Day &amp;d, const Month &amp;m, const Year &amp;y); ...&#125;;Date d(Day(5), Month(3), Year(1995)); 还有的解决方法是用类静态函数 1234567891011class Month &#123;public: static Month Jan() &#123; return Month(1); &#125; static Month Feb() &#123; return Month(2); &#125; ...private: explicit Month(int m): val(m) &#123;&#125; int val;&#125;Date d(Month::Mar(), Day(5), Year(1995)); 当然这种方法仅限于项数比较少的情况下，比较通用的还是上面struct的类型，也已经足够使用了。用类静态函数方法有两个注意点，一个是跟enum的区别，enum的类型安全性不足（能够当作int类型来使用)，第二个是构造函数是private的，也就是说，只能通过类静态函数获得月份。 接下来继续推销shared_ptr，因为shared_ptr能够直接管理好资源，并定制删除器，能够使用户省去很多不安全的操作，同时也更加的安全，如“跨DLL的new/delete成对运用”是会可能是会导致运行错误的（因为new/delete使用的是局部堆，也就是说不同的DLL虽然共享一个地址空间，但完全可能会维护不同的局部堆（堆分段），这与编译器的实现有关。有些编译器可以选择使用进程共享的局部堆，但性能会受影响。如果是不同的局部堆，当你在DLL中new时，是在DLL的堆中分配的，而当你在EXE中delete时，EXE会认为它是在EXE的局部堆中分配的，从而用EXE的堆信息去释放它，从而可能导致错误。具体情况与堆管理代码的实现有关。），而使用shared_ptr的删除器则是来自本身的DLL，因此能够更加安全。 条款19：设计class犹如设计type设计class需要考虑的问题包括但不限于，构造，赋值，传递操作，类型转换，继承，定义操作符，是否需要template等等。 条款20：宁以pass-by-reference-to-const替换pass-by-value对类减少拷贝构造函数，析构函数等开销。当然对基本类型和STL的来说，pass-by-value的得到了不少的优化，因此开销并不贵（比说说印象中，string中使用的写时拷贝技术）。 条款21：必须返回对象时，别妄想返回其reference不要搞返回local变量，静态变量的static，拷贝构造开销比出问题的时候带来的难题低太多了，除非如条款04那样，你知道你在做什么。 条款22：将成员变量声明为private无论是protected还是public，都降低了类的封装性，protected看似封装，但是对于继承类来说，其实封装性也是有不少的降低的。封装性带来的是代码修改维护的高效，因为对于直接public的成员，如果直接使用了，那么代码需要修改的地方则不仅仅是类，还包括了其他使用到了该public变量的地方。对protected成员也一样，对于继承类使用到的地方也是要逐一检查修改的。 条款23：宁以non-member、non-friend替换member函数同理，不必要地增加member函数，也使得类更加的臃肿，当non-member、non-friend函数能够实现的时候，也意味着该函数没必要作为member函数，提高封装性，也保留了扩展性。 条款24：若所有参数皆需类型转换，请为此采用non-member函数如有理数类与整数的乘法。 1234class Rational &#123; ... &#125;result = onehalf*2;result = 2*onehalf; 如果直接使用成员函数，那么会导致2*onehalf的错误，原因是int类型并没有乘以Rational的成员函数，同时也无法进行隐式转换。因此最能直接解决问题的是使用non-member函数，这写non-member函数的过程中就能够考虑好各种方面的。当然，根据上面的条款，能不使用friend函数就不使用。 条款25：考虑写出一个不抛异常的swap函数此处需要了解C++的模板特化与模板偏特化，还有一个地方需要的就是，不要试图全特化std的function template，因为这是未定义的行为，如 1234567891011121314151617181920212223242526272829303132333435template&lt;typename T&gt;class A &#123;public: A(int x): val(x) &#123; cout&lt;&lt;\"Construct\"&lt;&lt;endl; &#125; A(const A&amp; rhs): val(rhs.val) &#123; cout&lt;&lt;\"Copy Construct\"&lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;\"Deconstruct\"&lt;&lt;endl; &#125; const int get() const &#123; return val; &#125; void swap(A&amp; rhs) &#123; using std::swap; swap(this-&gt;val, rhs.val); &#125;private: T val;&#125;;namespace std &#123; template&lt;typename T&gt; void swap(A&lt;T&gt; &amp;rhs, A&lt;T&gt; &amp;lhs) &#123; cout&lt;&lt;\"Specialization\"&lt;&lt;endl; rhs.swap(lhs); &#125;&#125; 虽然代码简单而且运行起来并不会发现什么问题，但是实际上这样std::swap template全特化的过程是未定义行为，应该予以避免（如果去掉template的话，却是及格的偏特化)。最直接的用户应当是在另外的namespace中完成偏特化，然后在后续当中使用using std::swap，让编译器自己去选择最合适的swap函数。 此处，也可以得知std中swap的实现方法，类似于 123456template&lt;typename T&gt;void swap(T &amp;a, T &amp;b) &#123; T temp(a); a = b; b = a;&#125; 使用了一次拷贝构造函数和两次赋值函数以及一次的析构函数，达到安全的效果。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"effective-C++(3)","slug":"effective-c-3","date":"2019-03-04T02:08:10.000Z","updated":"2019-03-05T03:26:27.574Z","comments":true,"path":"2019/03/04/effective-c-3/","link":"","permalink":"http://yoursite.com/2019/03/04/effective-c-3/","excerpt":"","text":"条款13：以对象管理资源这一章基本都是推销智能指针， 以及讲智能指针可能需要注意的事情，但是稍微比较老了，还在讲auto_ptr的事情，印象中，C++11就已经废除了auto_ptr，只有unique_ptr，shared_ptr，weak_ptr三种指针了，因此后面还要补充一下这三种指针的实现，使用场景，还有具体为什么废除auto_ptr的原因，等等的关于智能指针的内容（希望记得）。 这里就讲到了一个很重要的概念，Resource Acquisition Is Initialization(RAII)，意思就是资源取得的时机也是它初始化的时间，在C++中，就需要很好地管理好变量的生命周期，防止return，exception等的出现，导致delete无法执行，进而导致资源泄露。那么解决方法就需要注意到，对于new的变量需要delete之外，作用域内声明的其它变量，都会被自动执行析构函数，因此就有了使用对象来管理资源的概念，对于new来说，自然可以实现一个智能的指针来实现资源的管理，当退出该作用域的时候，能够自动调用其析构函数，把资源还回去。 而使用智能指针的开始，需要注意的是，智能指针内执行的删除器一般来说（最起码是默认的），都是执行delete，而非delete []，所以交入智能指针的不要是new []的指针。 条款14：在资源管理类中小心copying行为当用智能指针管理指针的时候，可以考虑的问题（或者说好处）就多了起来，比如说复制的行为，一般来说有几种选择的可能。 禁止复制，就是私继承uncopyable。 对底层资源祭出“引用计数大法“，这也是shared_ptr实现的技术原理，能够保证使用的是同一个指针，保证资源能够被正确地释放，保证资源被释放之后不会被错误地使用，这都是通过”引用计数“这项技术来实现的。 复制底部资源，直接deep-copy，复制出一份一模一样的出来，当然，这一份只是一模一样，从逻辑上来讲，复制品指向的地方不一样了，复制品对进行修改的话，并不能修改原件。 转移底部资源的拥有权，像auto_ptr那样，直接转移使用权，原指针指向的地方变为空了（容易出错）。 条款15：在资源管理类中提供对原始资源的访问要能够对原始资源能够进行访问的原因是，可能有些函数，输入的参数需要是原始资源类型的，而非智能指针类型的，这时候就需要通过RAII class的API实现，一般来说有显示转换和隐式转换两种，显示转换是通过get API来实现的，而隐式转换则可以通过operator()来实现，究竟哪种方式比较合适，则是后面条款18考虑的问题。 条款16：成对使用new和delete时需要采用相同形式即new和delete配对，new []和delete []配对，否则将会产生未定义行为，很可能导致资源泄露。 条款17：以独立语句将newed对象置于智能指针假若有个场景是要求使用如下的代码的： 12int priority();void processWidget(std::tr1::shared_ptr&lt;Widget&gt; pw, int priority); 如果使用的方式是如下这样的： 1processWidget(new Widget, priority); 会导致问题，因为智能指针的构造函数是explicit的。 而这种实现方法1processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority()); 也会导致问题，因此priority的执行时间并不一定，不能保证执行顺序。如果是执行了new Widget之后再执行priority()，最后再放入shared_ptr中的话，那么如果priority()抛出异常，则会导致资源泄露。问题的原因在于函数中的comma operator在这里是作为sequence point，虽然a, b, c是保证按顺序执行的，但是在函数中func(arg1, arg2, arg3)的顺序则是未定义的，因此可能会出现那样的问题。最直接的改变方法就是如下 12std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget); // RAIIprocessWidget(pw, priority()); // 其实我看priority这样调用也不是很舒服（ 总的来说，反映出来要注意的问题就是new出来的对象，一定要保证把它能够立即交给智能指针管理，否则就会有隐患。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"effective-C++(2)","slug":"effective-C-2","date":"2019-02-25T06:29:22.000Z","updated":"2019-03-04T03:14:40.957Z","comments":true,"path":"2019/02/25/effective-C-2/","link":"","permalink":"http://yoursite.com/2019/02/25/effective-C-2/","excerpt":"","text":"条款05：了解C++默默编写并调用哪些函数一个完整的C++类，必然包含了构造函数，析构函数，copy构造函数，copy assignment操作符函数，如果没有写这些函数，那么编译器将会生成default版本的函数，大致来说，隐患主要来源于copy构造函数，copy assignment操作符函数过于暴力。默认版本的这两个函数都会直接将rhs的值粗暴地用等号赋值起来，那么对于const的成员，显然会直接报错，另外，对于引用值来说，也是一个很难发现的隐患，因为引用是不可以修改的，如下面的代码 12345string a = \"10\", b = \"1\";string &amp;c = a;cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;\" \"&lt;&lt;c&lt;&lt;endl;c = b;cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;\" \"&lt;&lt;c&lt;&lt;endl; 看意思似乎是将c更改为b的引用，然而实际上只会修改a的值为b，最终使得c仍为a的引用，然而a的值却改变成了b的值。在这简短的代码中，或许比较容易发现，然而在一段较复杂的类代码中，往往是个不容易发现的隐患。 解决这些隐患的方法有两个，第一个是养成自己书写这些会默认生成的函数的习惯，毕竟在简单的类中，实现这些代码并不费多少功夫，而在大的类当中，自然是必不可少的一环，减少bug的隐患。另外一个则是不需要这些函数的时候，将这些函数声明成private，并且只声明不实现，声明为private可以防止用户错误地使用这些有隐患的函数，只声明不实现能防止继承类中使用到这些不需要的函数。 条款06：若不想使用编译器自动生成的函数，就该明确拒绝正如上面所说，编译器为类自动生成的函数有不小的风险，当不需要的时候需要明确地拒绝编译器默认生成，阻止用户使用。在这个过程中，细节有两个，一个是只声明不实现，报错实际上是由编译器报错，而声明为private则是可以在连接器中报错，阻止member函数或friend函数对其进行使用。 而要把连接期的错误移到编译期报错是可以实现的（提早报错是好事），只需要实现一个不可复制的基类即可。 123456789101112131415class Uncopyable &#123;private: Uncopyable(Uncopyable&amp;); Uncopyable&amp; operator=(Uncopyable&amp;);public: Uncopyable() &#123; &#125; ~Uncopyable() &#123; &#125; &#125;;class Customer: private Uncopyable &#123;private: int id;public: Customer(int x): id(x) &#123;&#125;&#125;; 此处有几个可以注意一下的点。 Uncopyable的大小。尽管Uncopyable没有任何成员，sizeof(Uncopyable)仍然为1，因为class和struct的大小都应该大于零。实际上也有一种方法能够实现大小为0的类，就是添加一个大小为0的数组成员，如char s[0]，印象中方法是来自于陈硕的那本muduo。（晚点将该处的解释补上来） 尽管Uncopyable的大小为1，但是其派生类的大小会被编译器优化，如上述代码中Customer的大小就被优化成4了，即一个int的大小。 多重继承下，有些编译器不一定会把Uncopyable的大小优化到最优，但是往往会报warning：direct base ‘Uncopyable’ inaccessible in ‘XXX’ due to ambiguity。 Uncopyable的析构函数作为基类，不需要为virtual的原因是，它并不是作为多态基类的。（加了virtual函数的类的大小以后再深入讨论。） 条款07：为多态基类声明virtual析构函数因为使用多态的时候，需要类真正找到自己合适的析构方法，析构中正确地释放内存，防止内存泄漏或是触碰到不该碰的内存中，所以需要virtual的析构函数，通过virtual指针找到对应的析构函数（跟多态中的其他函数类似）。 而对于本来就不打算作为多态的base class，那么就不应该声明其析构函数为virtual，徒增占用空间。 条款08：别让异常逃离析构函数对于类来说，如果析构的过程中容易抛出异常，这时候就只有两种处理方法，一种是“吞掉异常”，不处理，往往会导致内存泄漏，一种则是“终止进程”，这往往是处理这种异常可取的方法。 然而，无论哪一种方法，都给程序带来了不小的风险，更合适的做法是用户在析构函数外，就将有异常风险的部分处理好，不要试图等到析构过程中出现异常再来处理。 条款09：绝不在构造和析构过程中调用virtual函数当了解了C++类的内存分布，以及构造过程之后就会了解比较深。主要原因就是virtual函数的调用是需要指针指向位置的，在无论是构造过程还是析构过程，都不能完全保证在调用之前，正确的函数指针已经构造完毕或是尚未析构，因此调用将会带来巨大的隐患。 条款10：令operator=返回一个reference to *this可以参考以下的两段代码： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class A &#123;public: A() &#123; cout&lt;&lt;\"Construct\"&lt;&lt;endl; &#125; A(const A&amp; rhs) &#123; cout&lt;&lt;\"Copy Construct\"&lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;\"Deconstruct\"&lt;&lt;endl; &#125; A operator=(const A&amp; rhs) &#123; return *this; &#125;&#125;;int main () &#123; A a, b, c; a = b = c; return 0;&#125; 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class A &#123;public: A() &#123; cout&lt;&lt;\"Construct\"&lt;&lt;endl; &#125; A(const A&amp; rhs) &#123; cout&lt;&lt;\"Copy Construct\"&lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;\"Deconstruct\"&lt;&lt;endl; &#125; A&amp; operator=(const A&amp; rhs) &#123; return *this; &#125;&#125;;int main () &#123; A a, b, c; a = b = c; return 0;&#125; 计算构造函数，拷贝构造函数，析构函数的使用次数，即可知道返回reference to *this会造成的资源浪费了。 条款11：在operator=中处理“自我赋值”先看一种很危险的赋值方法： 12345Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125; 考虑一下如果是自我赋值的话，那么这段代码会将自己给删除了，然后重新赋值，导致指针指向了一个被删除的对象。 再看一种比较危险的处理方法： 1234567Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; if (this == &amp;rhs) return *this; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125; 因为此处先删除了pb，再new bitmap，如果new的过程中因为内存不足等原因出现了异常，那么pb仍然指向了一个被删除的空间，看似安全，实际上没有避免掉本质问题，并非异常安全的。 接下来看安全的下实现版本： 123456Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; Bitmap* pOrig = pb; pb = new Bitmap(*rhs.pb); delete pOrig; return *this;&#125; 显然，这个版本直接处理了不安全的部分，是一种行得通的方法，只是效率并不高。 接下来是比较高效的实现方法，使用了copy and swap技术（异常安全技术）。 12345Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; Widget temp(rhs); swap(rhs); return *this;&#125; 这种技术首先制作了一份副本，然后跟原数据进行了交换，保证了自我赋值正确的同时，确保了异常安全。 更进一步还有这种实现方法： 1234Widget&amp; Widget::operator=(Widget rhs) &#123; swap(rhs); return *this;&#125; 实际上只是把制作副本的过程放到了参数构造中，让编译器可以生成更加高效的代码。 条款12：复制对象时勿忘其每一个成分复制对象的时候不仅要将本类的成员完成好拷贝，对于基类的成员也要保证拷贝完全，实现方法很简单，就是调用其基类的赋值函数。 123456789PriorityCustomer::PriorityCustomer(const PriorityCustomer &amp;rhs): Customer(rhs), priority(rhs.priority) &#123; &#125;PriorityCustomer&amp; PriorityCustomer::operator=(const PriorityCustomer &amp;rhs) &#123; Customer::operator=(rhs); priority = rhs.priority; return *this;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"effective C++(1)","slug":"effective-c-1","date":"2019-02-22T02:13:28.000Z","updated":"2019-03-11T09:23:28.559Z","comments":true,"path":"2019/02/22/effective-c-1/","link":"","permalink":"http://yoursite.com/2019/02/22/effective-c-1/","excerpt":"","text":"条款01： 视C++为一个语言联邦简单来说，就是四个次语言，C，object-oriented C++，template C++， stl。 实际上，入门C++很多年了，而且也不是第一次看effective c++了，现在借此博客来重新阅读学习一遍，并做一些总结。 条款02：尽量以const，enum，inline替换#define不使用#define的原因，主要可以用“宁可以编译器替换预处理器”来解释，就是说，#define的内容可能被预处理器直接替代，编译器并无法看到实际编程使用的记号，那么报错的时候将直接使用替代的元素，代码可读性可能没什么区别，但是编译报错之后可能很难定位bug的位置，毕竟当代码量变大的时候，很难回想起一个替换值的意义是什么，因此必要的时候，对于数值等内容可以使用const和enum来替代。 另外，使用#define来定义一些简短的函数，如#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))，当变得复杂，涉及到CALL_WITH_MAX(++a, b)的时候，几乎无法确定(a)被执行了多少次也影响了最终的结果，不加括号的话甚至有可能影响代码的执行顺序，当然这样的代码写法实属取不得，但是也暴露了 #define写法在替代过程中的危险性。要保留简短和高效性，不如使用inline函数。 同时，#define也拥有全局的特性，一旦定义，除非#undef，否则它将一直存在。如果想要具有局部性，有特定的使用区域，那么有两种方法： 使用static const。注意的是，如果需要取该变量的特定地址，就需要在实现文件（语法上可以在头文件，但是推荐是在实现文件）中定义声明一遍。（还有一种需要的可能是编译器（不正确地）需要。），如 12345678910// GamePlayer.hppclass GamePlayer &#123;private: static const int NumTurns = 5; int scores[NumTurns];&#125;;// Gameplayer.cppconst int GamePlayer::NumTurns = 5; 使用enum hack，这种方法更接近于#define，同时也有特定的指定范围，但是它并不能像const那样取得常量的地址，而相当于#define的记号，并不分配内存，而且编译错误中的报错并不像#define那样模糊。缺点在于enum必须是整型常数，对于浮点数或者是其他还是得老老实实使用const，应当注意到enum hack也是模板元编程中会使用的常用技巧之一，以后会说到。 123456789// GamePlayer.hppclass GamePlayer &#123;private: enum &#123; NumTurns = 5, another &#125;; int scores[NumTurns];&#125;; 条款03：尽可能使用const先来区分一下const老题目 12345char greeting[] = \"hello\";const char *p1 = greeting; // 非常量指针，常量数据，数据不可更改char* const p2 = greeting; // 常量指针，非常量数据，指针指向不可更改char const *p3 = greeting; // 非常量指针，常量数据，数据不可更改const char* const p4 = greeting; //常量指针，常量数据，都不可更改 现在首先讲到const返回对象，这个主要是防止使用函数的过程中出现误操作。如 123456789class Rational &#123;...&#125;;const Rational operator* (const Rational &amp;lhs, const Rational &amp;rhs);...Rational a, b, c;if (a * b = c) &#123; ...&#125; 上述例子中本来用来判断的==，写成了赋值，如果不是const类型，那么仍然能够通过编译，因为返回的是一个左值（如果返回int这些基本类型的，作为右值的，那么将会报错），而使用了const之后，因为是一个常量，赋值则会报错，进而避免了这种低级错误。而实际使用方面，如果需要赋值，尽管返回的是const，因为copy assignment函数的存在，因此并不会被影响，当然使用auto的话则需要注意一下了。（auto在此处也不应该这样贸然使用吧。） 接着是const成员函数，如下面的代码 12345678910111213141516171819202122232425262728293031class Text &#123;private: static const int another_size = 15; enum &#123; size = 10, another &#125;; char info[size];public: Text(const char p[]) &#123; int i=0; while (p[i] &amp;&amp; i &lt; size) &#123; info[i] = p[i]; i++; &#125; cout&lt;&lt;another_size&lt;&lt;endl; &#125; Text(const Text &amp;rhs) &#123; for (int i=0;i&lt;size;++i) &#123; info[i] = rhs.info[i]; &#125; &#125; const char &amp;operator[](int idx) const &#123; cout&lt;&lt;\"Const char operator\"&lt;&lt;endl; return info[idx]; &#125; char &amp;operator[](int idx) &#123; cout&lt;&lt;\"char operator\"&lt;&lt;endl; return info[idx]; &#125;&#125;; 对于operator[]函数，要实现两个版本的原因有两个，一个是对于const对象来说，如果没有const函数，那么将无法使用operator[]函数，因为可能涉及到修改，而若单纯有const operator[]自然也是无法修改内容的。而如果没有明确表明是const的话，编译器一般会选择operator[]版本的。 而在声明函数内为const，不会修改成员变量的时候，实在有一些成员需要修改，那么可以使用mutable关键字（不过感觉怪怪的）。 另外，如果const和非const版本的函数，内容几乎一致，但是为了const对象的使用，那么只能重新实现，但是为了减少代码的重用，可以使用下面的措施。 1234567891011121314class TextBlock &#123;public: const char &amp;operator[](int idx) const &#123; // ... // ... cout&lt;&lt;\"Const char operator\"&lt;&lt;endl; return info[idx]; &#125; char &amp;operator[](int idx) &#123; cout&lt;&lt;\"char operator\"&lt;&lt;endl; return const_cast&lt;char&amp;&gt;( static_cast&lt;const TextBlock&amp;&gt; (*this)[idx]); &#125;&#125;; 应当注意，上面的代码中第一个const_cast是为了去除const属性，使得返回出char&amp;，而第二个static_cast是为了构造出const TextBlock&amp;类型的对象，上面也提到，对于普通类型的如无明确需要默认会调用普通版本的operator[]，因此需要将对象转换为const的，保证调用const operator[]，避免陷入无限递归。通过两个cast实现了避免代码重用。 条款04：确定对象被使用前已先被初始化RAII是老生常谈的话题了，构造函数的初始化也是C++ class的基础内容，还要注意的是初始化的顺序，首先是base class先于derived class的构造，另外构造函数中，构造的顺序跟class中声明的顺序是一致的（不是构造函数冒号后的顺序），当然如无必要最好还是应该避免构造过程中，相互使用类中的变量。 接下来还有一个问题就是，non-local static对象的使用问题。 如下面代码所示 12345678910111213141516171819202122// FileSystemclass FileSystem &#123;public: ... std::size_t numDisks() const; ...&#125;;extern FileSystem tfs;// Directory class Directory &#123;public: Directory(params); &#125;;Directory::Directory(params) &#123; ... std::size_t disks = tfs.numDisks(); ...&#125;Directory tempDir(params); 因为tfs不一定在tempDir构造之前完成了初始化，它们都是不同编译单元内的non-local static对象，它的初始化相对顺序是未定义的，使用起来会陷入未定义行为的危险当中，而要保证tfs在tempDir之前完成初始化，则需要寻找可确定的初始化顺序。而我们知道，函数中的static变量，在调用函数之前必然会被事先完成初始化，那么就可以利用这一点，将non-local static对象转化为local static对象，进而保证初始化完成，同时，保证只有一个对象。 12345678910111213141516171819202122232425262728// FileSystemclass FileSystem &#123;public: ... std::size_t numDisks() const; ...&#125;;FileSystem&amp; tfs() &#123; static FileSystem fs; return fs&#125;// Directory class Directory &#123;public: Directory(params); &#125;;Directory::Directory(params) &#123; ... std::size_t disks = tfs().numDisks(); ...&#125;Directory&amp; tempDir(params) &#123; static Directory td(params); return td;&#125; 当然了，要保证使用一个对象，返回值必然是引用的，这也是Singleton模式的常见实现方法。思想是：以local static对象替换non-local static对象。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"leetcode(907)","slug":"leetcode-907","date":"2019-02-20T06:28:18.000Z","updated":"2019-02-20T07:19:50.317Z","comments":true,"path":"2019/02/20/leetcode-907/","link":"","permalink":"http://yoursite.com/2019/02/20/leetcode-907/","excerpt":"","text":"leetcode907题，题意很简单，就是计算数组所有的连续子数组的最小值的和。 有两种做法，一种是单调栈，一种是单调队列。 先说单调栈，思路就是找到数组中数字作为子数组最小值的左右边界，然后计算即可。如3 1 2 4，对于1来说，左边界就是最左端，右边界就是最右端，那么1作为最小值的子数组就有2×3个（离左端距离2，右端距离3），类似的，对2来说就是1×2。因此只需要计算得到每个数作为最小值的左右边界，即可完成。而要高效计算左右边界，则引入了单调栈的结构。 单调栈，顾名思义，它首先是一个栈，而且内部是单调有序的。使用单调栈的重要原因是，当我们从左到右，检测数字右边界的过程中，较大数能到达的右边界，那么它左边的较小数也能到达该右边界，因此可以统一处理，而较小数遇到了更小数的时候，较小数就不能继续到达右边界了。即查找右边界的时候，左边的数越小，越能到达该右边界。 计算左边界的思路同理，但是还有一个细节要注意的就是，左右边界的等号处理问题，就是遇到相同的数字的时候，要控制某一边的边界不变，来捕获大数组，而不构成重复，考虑3 1 2 3 1 4，碰到1的时候的处理细节即可。 AC代码： 1234567891011121314151617181920212223242526272829class Solution &#123;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; stack&lt;int&gt; st1, st2; int n = A.size(); vector&lt;int&gt; left(n, -1), right(n, n); for (int i=0;i&lt;n;++i) &#123; while (!st1.empty() &amp;&amp; A[st1.top()] &gt;= A[i]) &#123; right[st1.top()] = i; st1.pop(); &#125; st1.push(i); &#125; for (int i=n-1;i&gt;=0;--i) &#123; while (!st2.empty() &amp;&amp; A[st2.top()] &gt; A[i]) &#123; left[st2.top()] = i; st2.pop(); &#125; st2.push(i); &#125; int ans = 0; for (int i=0;i&lt;n;++i) &#123; ans += (left[i] - i) * (i-right[i]) * A[i]; ans %= 1000000007; &#125; return ans; &#125;&#125;; 时间和空间复杂度为O(n)。 接下来是单调队列的做法。单调队列是我最先想到的方法，但是初始版本的最坏复杂度过高，因此先放下来了。基本思路是这样的，比如说3 1 2 4，从左往右扫的过程中，先碰到3，3自然可以作为一个子数组，得到3，而继续扫的过程中，遇到了1，那么从3开始的数组，若碰到了1，那么接下来的最小值就是1了，另外，从1开始的数组，其子数组的最小值自然也是1，会得到队列1 1，接下来碰到了2，因为2比1小，所以2要作为最小值，只能重新开始作为新的子数组，而1可以继续延续作为子数组，得到队列1 1 2，到了4，队列就变成了1 1 3 4，最终结果就是每一个队列的和的和，这个和可以通过每一次的维护队列过程来进行维护。代码如下： AC代码： 123456789101112131415161718192021222324class Solution &#123;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; vector&lt;int&gt; que; int n = A.size(), sum = A[0]; que.push_back(A[0]); int cnt = 1, cur = A[0]; for (int i=1;i&lt;n;++i) &#123; int j = cnt - 1; while (j &gt;= 0 &amp;&amp; que[j] &gt; A[i]) &#123; cur = cur - que[j] + A[i]; que[j] = A[i]; j--; &#125; cnt++; cur += A[i]; que.push_back(A[i]); sum += cur; cur %= 1000000007; sum %= 1000000007; &#125; return sum; &#125;&#125;; 当然这个算法的最坏复杂度是O(n^2)，自然是不够看的。 实际上，可以发现队列是有序的，因此维护序列的过程中，可以通过二分查找来进行优化，优化之后结果的AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;private: int upperb(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;que, int size, int target) &#123; int left = 0; while (size &gt; 0) &#123; int half = size&gt;&gt;1; int mid = left+half; int idx = que[mid]; if (A[idx] &lt;= target) &#123; left = mid+1; size = size - half - 1; &#125; else &#123; size = half; &#125; &#125; return left; &#125;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); vector&lt;int&gt; que(n), cursum(n); que[0] = 0; cursum[0] = A[0]; int cur = 1, sum = A[0]; for (int i=1;i&lt;n;++i) &#123; int p = upperb(A, que, cur, A[i]); if (p == 0) &#123; cursum[0] = A[i]*(i+1); que[0] = i; cur = 1; &#125; else &#123; cursum[p] = cursum[p-1] + A[i]*(i-que[p-1]); que[p] = i; cur = p+1; &#125; sum += cursum[cur-1]; cursum[cur-1] %= 1000000007; sum %= 1000000007; &#125; return sum; &#125;&#125;; 最坏复杂度是O(nlogn)，不过这是一个比较松的上界，实际表现比上面的单调栈代码快一丢丢。 补充一个二分查找的写法，这里二分查找优化是需要自己写，而不能单纯使用upper_bound这些的，我个人比较喜欢的写法是stl标准库的写法，有个first，size，二分过程中用half，可以自己去查阅文档啦~","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]}]}