{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"effective c++(1)","slug":"effective-c-1","date":"2019-02-22T02:13:28.000Z","updated":"2019-02-22T07:53:39.534Z","comments":true,"path":"2019/02/22/effective-c-1/","link":"","permalink":"http://yoursite.com/2019/02/22/effective-c-1/","excerpt":"","text":"条款01： 视C++为一个语言联邦简单来说，就是四个次语言，C，object-oriented C++，template C++， stl。 实际上，入门C++很多年了，而且也不是第一次看effective c++了，现在借此博客来重新阅读学习一遍，并做一些总结。 条款02：尽量以const，enum，inline替换#define不使用#define的原因，主要可以用“宁可以编译器替换预处理器”来解释，就是说，#define的内容可能被预处理器直接替代，编译器并无法看到实际编程使用的记号，那么报错的时候将直接使用替代的元素，代码可读性可能没什么区别，但是编译报错之后可能很难定位bug的位置，毕竟当代码量变大的时候，很难回想起一个替换值的意义是什么，因此必要的时候，对于数值等内容可以使用const和enum来替代。 另外，使用#define来定义一些简短的函数，如#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))，当变得复杂，涉及到CALL_WITH_MAX(++a, b)的时候，几乎无法确定(a)被执行了多少次也影响了最终的结果，不加括号的话甚至有可能影响代码的执行顺序，当然这样的代码写法实属取不得，但是也暴露了 #define写法在替代过程中的危险性。要保留简短和高效性，不如使用inline函数。 同时，#define也拥有全局的特性，一旦定义，除非#undef，否则它将一直存在。如果想要具有局部性，有特定的使用区域，那么有两种方法： 使用static const。注意的是，如果需要取该变量的特定地址，就需要在实现文件（语法上可以在头文件，但是推荐是在实现文件）中定义声明一遍。（还有一种需要的可能是编译器（不正确地）需要。），如 12345678910// GamePlayer.hppclass GamePlayer &#123;private: static const int NumTurns = 5; int scores[NumTurns];&#125;;// Gameplayer.cppconst int GamePlayer::NumTurns = 5; 使用enum hack，这种方法更接近于#define，同时也有特定的指定范围，但是它并不能像const那样取得常量的地址，而相当于#define的记号，并不分配内存，而且编译错误中的报错并不像#define那样模糊。缺点在于enum必须是整型常数，对于浮点数或者是其他还是得老老实实使用const，应当注意到enum hack也是模板元编程中会使用的常用技巧之一，以后会说到。 123456789// GamePlayer.hppclass GamePlayer &#123;private: enum &#123; NumTurns = 5, another &#125;; int scores[NumTurns];&#125;; 条款03：尽可能使用const先来区分一下const老题目 12345char greeting[] = \"hello\";const char *p1 = greeting; // 非常量指针，常量数据，数据不可更改char* const p2 = greeting; // 常量指针，非常量数据，指针指向不可更改char const *p3 = greeting; // 非常量指针，常量数据，数据不可更改const char* const p4 = greeting; //常量指针，常量数据，都不可更改 现在首先讲到const返回对象，这个主要是防止使用函数的过程中出现误操作。如 123456789class Rational &#123;...&#125;;const Rational operator* (const Rational &amp;lhs, const Rational &amp;rhs);...Rational a, b, c;if (a * b = c) &#123; ...&#125; 上述例子中本来用来判断的==，写成了赋值，如果不是const类型，那么仍然能够通过编译，因为返回的是一个左值（如果返回int这些基本类型的，作为右值的，那么将会报错），而使用了const之后，因为是一个常量，赋值则会报错，进而避免了这种低级错误。而实际使用方面，如果需要赋值，尽管返回的是const，因为copy assignment函数的存在，因此并不会被影响，当然使用auto的话则需要注意一下了。（auto在此处也不应该这样贸然使用吧。） 接着是const成员函数，如下面的代码 12345678910111213141516171819202122232425262728293031class Text &#123;private: static const int another_size = 15; enum &#123; size = 10, another &#125;; char info[size];public: Text(const char p[]) &#123; int i=0; while (p[i] &amp;&amp; i &lt; size) &#123; info[i] = p[i]; i++; &#125; cout&lt;&lt;another_size&lt;&lt;endl; &#125; Text(const Text &amp;rhs) &#123; for (int i=0;i&lt;size;++i) &#123; info[i] = rhs.info[i]; &#125; &#125; const char &amp;operator[](int idx) const &#123; cout&lt;&lt;\"Const char operator\"&lt;&lt;endl; return info[idx]; &#125; char &amp;operator[](int idx) &#123; cout&lt;&lt;\"char operator\"&lt;&lt;endl; return info[idx]; &#125;&#125;; 对于operator[]函数，要实现两个版本的原因有两个，一个是对于const对象来说，如果没有const函数，那么将无法使用operator[]函数，因为可能涉及到修改，而若单纯有const operator[]自然也是无法修改内容的。而如果没有明确表明是const的话，编译器一般会选择operator[]版本的。 而在声明函数内为const，不会修改成员变量的时候，实在有一些成员需要修改，那么可以使用mutable关键字（不过感觉怪怪的）。、 另外，如果const和非const版本的函数，内容几乎一致，但是为了const对象的使用，那么只能重新实现，但是为了减少代码的重用，可以使用下面的措施。 1234567891011121314class TextBlock &#123;public: const char &amp;operator[](int idx) const &#123; // ... // ... cout&lt;&lt;\"Const char operator\"&lt;&lt;endl; return info[idx]; &#125; char &amp;operator[](int idx) &#123; cout&lt;&lt;\"char operator\"&lt;&lt;endl; return const_cast&lt;char&amp;&gt;( static_cast&lt;const TextBlock&amp;&gt; (*this)[idx]); &#125;&#125;; 应当注意，上面的代码中第一个const_cast是为了去除const属性，使得返回出char&amp;，而第二个static_cast是为了构造出const TextBlock&amp;类型的对象，上面也提到，对于普通类型的如无明确需要默认会调用普通版本的operator[]，因此需要将对象转换为const的，保证调用const operator[]，避免陷入无限递归。通过两个cast实现了避免代码重用。 条款04：确定对象被使用前已先被初始化RAII是老生常谈的话题了，构造函数的初始化也是C++ class的基础内容，还要注意的是初始化的顺序，首先是base class先于derived class的构造，另外构造函数中，构造的顺序跟class中声明的顺序是一致的（不是构造函数冒号后的顺序），当然如无必要最好还是应该避免构造过程中，相互使用类中的变量。 接下来还有一个问题就是，non-local static对象的使用问题。 如下面代码所示 12345678910111213141516171819202122// FileSystemclass FileSystem &#123;public: ... std::size_t numDisks() const; ...&#125;;extern FileSystem tfs;// Directory class Directory &#123;public: Directory(params); &#125;;Directory::Directory(params) &#123; ... std::size_t disks = tfs.numDisks(); ...&#125;Directory tempDir(params); 因为tfs不一定在tempDir构造之前完成了初始化，它们都是不同编译单元内的non-local static对象，它的初始化相对顺序是未定义的，使用起来会陷入未定义行为的危险当中，而要保证tfs在tempDir之前完成初始化，则需要寻找可确定的初始化顺序。而我们知道，函数中的static变量，在调用函数之前必然会被事先完成初始化，那么就可以利用这一点，将non-local static对象转化为local static对象，进而保证初始化完成，同时，保证只有一个对象。 12345678910111213141516171819202122232425262728// FileSystemclass FileSystem &#123;public: ... std::size_t numDisks() const; ...&#125;;FileSystem&amp; tfs() &#123; static FileSystem fs; return fs&#125;// Directory class Directory &#123;public: Directory(params); &#125;;Directory::Directory(params) &#123; ... std::size_t disks = tfs().numDisks(); ...&#125;Directory&amp; tempDir(params) &#123; static Directory td(params); return td;&#125; 当然了，要保证使用一个对象，返回值必然是引用的，这也是Singleton模式的常见实现方法。思想是：以local static对象替换non-local static对象。","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"leetcode(907)","slug":"leetcode-907","date":"2019-02-20T06:28:18.000Z","updated":"2019-02-20T07:19:50.317Z","comments":true,"path":"2019/02/20/leetcode-907/","link":"","permalink":"http://yoursite.com/2019/02/20/leetcode-907/","excerpt":"","text":"leetcode907题，题意很简单，就是计算数组所有的连续子数组的最小值的和。 有两种做法，一种是单调栈，一种是单调队列。 先说单调栈，思路就是找到数组中数字作为子数组最小值的左右边界，然后计算即可。如3 1 2 4，对于1来说，左边界就是最左端，右边界就是最右端，那么1作为最小值的子数组就有2×3个（离左端距离2，右端距离3），类似的，对2来说就是1×2。因此只需要计算得到每个数作为最小值的左右边界，即可完成。而要高效计算左右边界，则引入了单调栈的结构。 单调栈，顾名思义，它首先是一个栈，而且内部是单调有序的。使用单调栈的重要原因是，当我们从左到右，检测数字右边界的过程中，较大数能到达的右边界，那么它左边的较小数也能到达该右边界，因此可以统一处理，而较小数遇到了更小数的时候，较小数就不能继续到达右边界了。即查找右边界的时候，左边的数越小，越能到达该右边界。 计算左边界的思路同理，但是还有一个细节要注意的就是，左右边界的等号处理问题，就是遇到相同的数字的时候，要控制某一边的边界不变，来捕获大数组，而不构成重复，考虑3 1 2 3 1 4，碰到1的时候的处理细节即可。 AC代码： 1234567891011121314151617181920212223242526272829class Solution &#123;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; stack&lt;int&gt; st1, st2; int n = A.size(); vector&lt;int&gt; left(n, -1), right(n, n); for (int i=0;i&lt;n;++i) &#123; while (!st1.empty() &amp;&amp; A[st1.top()] &gt;= A[i]) &#123; right[st1.top()] = i; st1.pop(); &#125; st1.push(i); &#125; for (int i=n-1;i&gt;=0;--i) &#123; while (!st2.empty() &amp;&amp; A[st2.top()] &gt; A[i]) &#123; left[st2.top()] = i; st2.pop(); &#125; st2.push(i); &#125; int ans = 0; for (int i=0;i&lt;n;++i) &#123; ans += (left[i] - i) * (i-right[i]) * A[i]; ans %= 1000000007; &#125; return ans; &#125;&#125;; 时间和空间复杂度为O(n)。 接下来是单调队列的做法。单调队列是我最先想到的方法，但是初始版本的最坏复杂度过高，因此先放下来了。基本思路是这样的，比如说3 1 2 4，从左往右扫的过程中，先碰到3，3自然可以作为一个子数组，得到3，而继续扫的过程中，遇到了1，那么从3开始的数组，若碰到了1，那么接下来的最小值就是1了，另外，从1开始的数组，其子数组的最小值自然也是1，会得到队列1 1，接下来碰到了2，因为2比1小，所以2要作为最小值，只能重新开始作为新的子数组，而1可以继续延续作为子数组，得到队列1 1 2，到了4，队列就变成了1 1 3 4，最终结果就是每一个队列的和的和，这个和可以通过每一次的维护队列过程来进行维护。代码如下： AC代码： 123456789101112131415161718192021222324class Solution &#123;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; vector&lt;int&gt; que; int n = A.size(), sum = A[0]; que.push_back(A[0]); int cnt = 1, cur = A[0]; for (int i=1;i&lt;n;++i) &#123; int j = cnt - 1; while (j &gt;= 0 &amp;&amp; que[j] &gt; A[i]) &#123; cur = cur - que[j] + A[i]; que[j] = A[i]; j--; &#125; cnt++; cur += A[i]; que.push_back(A[i]); sum += cur; cur %= 1000000007; sum %= 1000000007; &#125; return sum; &#125;&#125;; 当然这个算法的最坏复杂度是O(n^2)，自然是不够看的。 实际上，可以发现队列是有序的，因此维护序列的过程中，可以通过二分查找来进行优化，优化之后结果的AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;private: int upperb(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;que, int size, int target) &#123; int left = 0; while (size &gt; 0) &#123; int half = size&gt;&gt;1; int mid = left+half; int idx = que[mid]; if (A[idx] &lt;= target) &#123; left = mid+1; size = size - half - 1; &#125; else &#123; size = half; &#125; &#125; return left; &#125;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); vector&lt;int&gt; que(n), cursum(n); que[0] = 0; cursum[0] = A[0]; int cur = 1, sum = A[0]; for (int i=1;i&lt;n;++i) &#123; int p = upperb(A, que, cur, A[i]); if (p == 0) &#123; cursum[0] = A[i]*(i+1); que[0] = i; cur = 1; &#125; else &#123; cursum[p] = cursum[p-1] + A[i]*(i-que[p-1]); que[p] = i; cur = p+1; &#125; sum += cursum[cur-1]; cursum[cur-1] %= 1000000007; sum %= 1000000007; &#125; return sum; &#125;&#125;; 最坏复杂度是O(nlogn)，不过这是一个比较松的上界，实际表现比上面的单调栈代码快一丢丢。 补充一个二分查找的写法，这里二分查找优化是需要自己写，而不能单纯使用upper_bound这些的，我个人比较喜欢的写法是stl标准库的写法，有个first，size，二分过程中用half，可以自己去查阅文档啦~","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]}]}