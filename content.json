{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"effetive-C++(3)","slug":"effetive-c-3","date":"2019-03-04T02:08:10.000Z","updated":"2019-03-04T03:14:44.117Z","comments":true,"path":"2019/03/04/effetive-c-3/","link":"","permalink":"http://yoursite.com/2019/03/04/effetive-c-3/","excerpt":"","text":"条款13：以对象管理资源这一章基本都是推销智能指针， 以及讲智能指针可能需要注意的事情，但是稍微比较老了，还在讲auto_ptr的事情，印象中，C++11就已经废除了auto_ptr，只有unique_ptr，shared_ptr，weak_ptr三种指针了，因此后面还要补充一下这三种指针的实现，使用场景，还有具体为什么废除auto_ptr的原因，等等的关于智能指针的内容（希望记得）。 这里就讲到了一个很重要的概念，Resource Acquisition Is Initialization(RAII)，意思就是资源取得的时机也是它初始化的时间，在C++中，就需要很好地管理好变量的生命周期，防止return，exception等的出现，导致delete无法执行，进而导致资源泄露。那么解决方法就需要注意到，对于new的变量需要delete之外，作用域内声明的其它变量，都会被自动执行析构函数，因此就有了使用对象来管理资源的概念，对于new来说，自然可以实现一个智能的指针来实现资源的管理，当退出该作用域的时候，能够自动调用其析构函数，把资源还回去。 而使用智能指针的开始，需要注意的是，智能指针内执行的删除器一般来说（最起码是默认的），都是执行delete，而非delete []，所以交入智能指针的不要是new []的指针。 条款14：在资源管理类中小心copying行为当用智能指针管理指针的时候，可以考虑的问题（或者说好处）就多了起来，比如说复制的行为，一般来说有几种选择的可能。 禁止复制，就是私继承uncopyable。 对底层资源祭出“引用计数大法“，这也是shared_ptr实现的技术原理，能够保证使用的是同一个指针，保证资源能够被正确地释放，保证资源被释放之后不会被错误地使用，这都是通过”引用计数“这项技术来实现的。 复制底部资源，直接deep-copy，复制出一份一模一样的出来，当然，这一份只是一模一样，从逻辑上来讲，复制品指向的地方不一样了，复制品对进行修改的话，并不能修改原件。 转移底部资源的拥有权，像auto_ptr那样，直接转移使用权，原指针指向的地方变为空了（容易出错）。 条款15：在资源管理类中提供对原始资源的访问要能够对原始资源能够进行访问的原因是，可能有些函数，输入的参数需要是原始资源类型的，而非智能指针类型的，这时候就需要通过RAII class的API实现，一般来说有显示转换和隐式转换两种，显示转换是通过get API来实现的，而隐式转换则可以通过operator()来实现，究竟哪种方式比较合适，则是后面条款18考虑的问题。 条款16：成对使用new和delete时需要采用相同形式即new和delete配对，new []和delete []配对，否则将会产生未定义行为，很可能导致资源泄露。 条款17：以独立语句将newed对象置于智能指针假若有个场景是要求使用如下的代码的： 12int priority();void processWidget(std::tr1::shared_ptr&lt;Widget&gt; pw, int priority); 如果使用的方式是如下这样的： 1processWidget(new Widget, priority); 会导致问题，因为智能指针的构造函数是explicit的。 而这种实现方法1processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority()); 也会导致问题，因此priority的执行时间并不一定，不能保证执行顺序。如果是执行了new Widget之后再执行priority()，最后再放入shared_ptr中的话，那么如果priority()抛出异常，则会导致资源泄露。问题的原因在于函数中的comma operator在这里是作为sequence point，虽然a, b, c是保证按顺序执行的，但是在函数中func(arg1, arg2, arg3)的顺序则是未定义的，因此可能会出现那样的问题。最直接的改变方法就是如下 12std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget); // RAIIprocessWidget(pw, priority()); // 其实我看priority这样调用也不是很舒服（ 总的来说，反映出来要注意的问题就是new出来的对象，一定要保证把它能够立即交给智能指针管理，否则就会有隐患。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"effective-C++(2)","slug":"effective-C-2","date":"2019-02-25T06:29:22.000Z","updated":"2019-03-04T03:14:40.957Z","comments":true,"path":"2019/02/25/effective-C-2/","link":"","permalink":"http://yoursite.com/2019/02/25/effective-C-2/","excerpt":"","text":"条款05：了解C++默默编写并调用哪些函数一个完整的C++类，必然包含了构造函数，析构函数，copy构造函数，copy assignment操作符函数，如果没有写这些函数，那么编译器将会生成default版本的函数，大致来说，隐患主要来源于copy构造函数，copy assignment操作符函数过于暴力。默认版本的这两个函数都会直接将rhs的值粗暴地用等号赋值起来，那么对于const的成员，显然会直接报错，另外，对于引用值来说，也是一个很难发现的隐患，因为引用是不可以修改的，如下面的代码 12345string a = \"10\", b = \"1\";string &amp;c = a;cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;\" \"&lt;&lt;c&lt;&lt;endl;c = b;cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;\" \"&lt;&lt;c&lt;&lt;endl; 看意思似乎是将c更改为b的引用，然而实际上只会修改a的值为b，最终使得c仍为a的引用，然而a的值却改变成了b的值。在这简短的代码中，或许比较容易发现，然而在一段较复杂的类代码中，往往是个不容易发现的隐患。 解决这些隐患的方法有两个，第一个是养成自己书写这些会默认生成的函数的习惯，毕竟在简单的类中，实现这些代码并不费多少功夫，而在大的类当中，自然是必不可少的一环，减少bug的隐患。另外一个则是不需要这些函数的时候，将这些函数声明成private，并且只声明不实现，声明为private可以防止用户错误地使用这些有隐患的函数，只声明不实现能防止继承类中使用到这些不需要的函数。 条款06：若不想使用编译器自动生成的函数，就该明确拒绝正如上面所说，编译器为类自动生成的函数有不小的风险，当不需要的时候需要明确地拒绝编译器默认生成，阻止用户使用。在这个过程中，细节有两个，一个是只声明不实现，报错实际上是由编译器报错，而声明为private则是可以在连接器中报错，阻止member函数或friend函数对其进行使用。 而要把连接期的错误移到编译期报错是可以实现的（提早报错是好事），只需要实现一个不可复制的基类即可。 123456789101112131415class Uncopyable &#123;private: Uncopyable(Uncopyable&amp;); Uncopyable&amp; operator=(Uncopyable&amp;);public: Uncopyable() &#123; &#125; ~Uncopyable() &#123; &#125; &#125;;class Customer: private Uncopyable &#123;private: int id;public: Customer(int x): id(x) &#123;&#125;&#125;; 此处有几个可以注意一下的点。 Uncopyable的大小。尽管Uncopyable没有任何成员，sizeof(Uncopyable)仍然为1，因为class和struct的大小都应该大于零。实际上也有一种方法能够实现大小为0的类，就是添加一个大小为0的数组成员，如char s[0]，印象中方法是来自于陈硕的那本muduo。（晚点将该处的解释补上来） 尽管Uncopyable的大小为1，但是其派生类的大小会被编译器优化，如上述代码中Customer的大小就被优化成4了，即一个int的大小。 多重继承下，有些编译器不一定会把Uncopyable的大小优化到最优，但是往往会报warning：direct base ‘Uncopyable’ inaccessible in ‘XXX’ due to ambiguity。 Uncopyable的析构函数作为基类，不需要为virtual的原因是，它并不是作为多态基类的。（加了virtual函数的类的大小以后再深入讨论。） 条款07：为多态基类声明virtual析构函数因为使用多态的时候，需要类真正找到自己合适的析构方法，析构中正确地释放内存，防止内存泄漏或是触碰到不该碰的内存中，所以需要virtual的析构函数，通过virtual指针找到对应的析构函数（跟多态中的其他函数类似）。 而对于本来就不打算作为多态的base class，那么就不应该声明其析构函数为virtual，徒增占用空间。 条款08：别让异常逃离析构函数对于类来说，如果析构的过程中容易抛出异常，这时候就只有两种处理方法，一种是“吞掉异常”，不处理，往往会导致内存泄漏，一种则是“终止进程”，这往往是处理这种异常可取的方法。 然而，无论哪一种方法，都给程序带来了不小的风险，更合适的做法是用户在析构函数外，就将有异常风险的部分处理好，不要试图等到析构过程中出现异常再来处理。 条款09：绝不在构造和析构过程中调用virtual函数当了解了C++类的内存分布，以及构造过程之后就会了解比较深。主要原因就是virtual函数的调用是需要指针指向位置的，在无论是构造过程还是析构过程，都不能完全保证在调用之前，正确的函数指针已经构造完毕或是尚未析构，因此调用将会带来巨大的隐患。 条款10：令operator=返回一个reference to *this可以参考以下的两段代码： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class A &#123;public: A() &#123; cout&lt;&lt;\"Construct\"&lt;&lt;endl; &#125; A(const A&amp; rhs) &#123; cout&lt;&lt;\"Copy Construct\"&lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;\"Deconstruct\"&lt;&lt;endl; &#125; A operator=(const A&amp; rhs) &#123; return *this; &#125;&#125;;int main () &#123; A a, b, c; a = b = c; return 0;&#125; 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class A &#123;public: A() &#123; cout&lt;&lt;\"Construct\"&lt;&lt;endl; &#125; A(const A&amp; rhs) &#123; cout&lt;&lt;\"Copy Construct\"&lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;\"Deconstruct\"&lt;&lt;endl; &#125; A&amp; operator=(const A&amp; rhs) &#123; return *this; &#125;&#125;;int main () &#123; A a, b, c; a = b = c; return 0;&#125; 计算构造函数，拷贝构造函数，析构函数的使用次数，即可知道返回reference to *this会造成的资源浪费了。 条款11：在operator=中处理“自我赋值”先看一种很危险的赋值方法： 12345Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125; 考虑一下如果是自我赋值的话，那么这段代码会将自己给删除了，然后重新赋值，导致指针指向了一个被删除的对象。 再看一种比较危险的处理方法： 1234567Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; if (this == &amp;rhs) return *this; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125; 因为此处先删除了pb，再new bitmap，如果new的过程中因为内存不足等原因出现了异常，那么pb仍然指向了一个被删除的空间，看似安全，实际上没有避免掉本质问题，并非异常安全的。 接下来看安全的下实现版本： 123456Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; Bitmap* pOrig = pb; pb = new Bitmap(*rhs.pb); delete pOrig; return *this;&#125; 显然，这个版本直接处理了不安全的部分，是一种行得通的方法，只是效率并不高。 接下来是比较高效的实现方法，使用了copy and swap技术（异常安全技术）。 12345Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; Widget temp(rhs); swap(rhs); return *this;&#125; 这种技术首先制作了一份副本，然后跟原数据进行了交换，保证了自我赋值正确的同时，确保了异常安全。 更进一步还有这种实现方法： 1234Widget&amp; Widget::operator=(Widget rhs) &#123; swap(rhs); return *this;&#125; 实际上只是把制作副本的过程放到了参数构造中，让编译器可以生成更加高效的代码。 条款12：复制对象时勿忘其每一个成分复制对象的时候不仅要将本类的成员完成好拷贝，对于基类的成员也要保证拷贝完全，实现方法很简单，就是调用其基类的赋值函数。 123456789PriorityCustomer::PriorityCustomer(const PriorityCustomer &amp;rhs): Customer(rhs), priority(rhs.priority) &#123; &#125;PriorityCustomer&amp; PriorityCustomer::operator=(const PriorityCustomer &amp;rhs) &#123; Customer::operator=(rhs); priority = rhs.priority; return *this;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"effective C++(1)","slug":"effective-c-1","date":"2019-02-22T02:13:28.000Z","updated":"2019-03-04T03:14:28.811Z","comments":true,"path":"2019/02/22/effective-c-1/","link":"","permalink":"http://yoursite.com/2019/02/22/effective-c-1/","excerpt":"","text":"条款01： 视C++为一个语言联邦简单来说，就是四个次语言，C，object-oriented C++，template C++， stl。 实际上，入门C++很多年了，而且也不是第一次看effective c++了，现在借此博客来重新阅读学习一遍，并做一些总结。 条款02：尽量以const，enum，inline替换#define不使用#define的原因，主要可以用“宁可以编译器替换预处理器”来解释，就是说，#define的内容可能被预处理器直接替代，编译器并无法看到实际编程使用的记号，那么报错的时候将直接使用替代的元素，代码可读性可能没什么区别，但是编译报错之后可能很难定位bug的位置，毕竟当代码量变大的时候，很难回想起一个替换值的意义是什么，因此必要的时候，对于数值等内容可以使用const和enum来替代。 另外，使用#define来定义一些简短的函数，如#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))，当变得复杂，涉及到CALL_WITH_MAX(++a, b)的时候，几乎无法确定(a)被执行了多少次也影响了最终的结果，不加括号的话甚至有可能影响代码的执行顺序，当然这样的代码写法实属取不得，但是也暴露了 #define写法在替代过程中的危险性。要保留简短和高效性，不如使用inline函数。 同时，#define也拥有全局的特性，一旦定义，除非#undef，否则它将一直存在。如果想要具有局部性，有特定的使用区域，那么有两种方法： 使用static const。注意的是，如果需要取该变量的特定地址，就需要在实现文件（语法上可以在头文件，但是推荐是在实现文件）中定义声明一遍。（还有一种需要的可能是编译器（不正确地）需要。），如 12345678910// GamePlayer.hppclass GamePlayer &#123;private: static const int NumTurns = 5; int scores[NumTurns];&#125;;// Gameplayer.cppconst int GamePlayer::NumTurns = 5; 使用enum hack，这种方法更接近于#define，同时也有特定的指定范围，但是它并不能像const那样取得常量的地址，而相当于#define的记号，并不分配内存，而且编译错误中的报错并不像#define那样模糊。缺点在于enum必须是整型常数，对于浮点数或者是其他还是得老老实实使用const，应当注意到enum hack也是模板元编程中会使用的常用技巧之一，以后会说到。 123456789// GamePlayer.hppclass GamePlayer &#123;private: enum &#123; NumTurns = 5, another &#125;; int scores[NumTurns];&#125;; 条款03：尽可能使用const先来区分一下const老题目 12345char greeting[] = \"hello\";const char *p1 = greeting; // 非常量指针，常量数据，数据不可更改char* const p2 = greeting; // 常量指针，非常量数据，指针指向不可更改char const *p3 = greeting; // 非常量指针，常量数据，数据不可更改const char* const p4 = greeting; //常量指针，常量数据，都不可更改 现在首先讲到const返回对象，这个主要是防止使用函数的过程中出现误操作。如 123456789class Rational &#123;...&#125;;const Rational operator* (const Rational &amp;lhs, const Rational &amp;rhs);...Rational a, b, c;if (a * b = c) &#123; ...&#125; 上述例子中本来用来判断的==，写成了赋值，如果不是const类型，那么仍然能够通过编译，因为返回的是一个左值（如果返回int这些基本类型的，作为右值的，那么将会报错），而使用了const之后，因为是一个常量，赋值则会报错，进而避免了这种低级错误。而实际使用方面，如果需要赋值，尽管返回的是const，因为copy assignment函数的存在，因此并不会被影响，当然使用auto的话则需要注意一下了。（auto在此处也不应该这样贸然使用吧。） 接着是const成员函数，如下面的代码 12345678910111213141516171819202122232425262728293031class Text &#123;private: static const int another_size = 15; enum &#123; size = 10, another &#125;; char info[size];public: Text(const char p[]) &#123; int i=0; while (p[i] &amp;&amp; i &lt; size) &#123; info[i] = p[i]; i++; &#125; cout&lt;&lt;another_size&lt;&lt;endl; &#125; Text(const Text &amp;rhs) &#123; for (int i=0;i&lt;size;++i) &#123; info[i] = rhs.info[i]; &#125; &#125; const char &amp;operator[](int idx) const &#123; cout&lt;&lt;\"Const char operator\"&lt;&lt;endl; return info[idx]; &#125; char &amp;operator[](int idx) &#123; cout&lt;&lt;\"char operator\"&lt;&lt;endl; return info[idx]; &#125;&#125;; 对于operator[]函数，要实现两个版本的原因有两个，一个是对于const对象来说，如果没有const函数，那么将无法使用operator[]函数，因为可能涉及到修改，而若单纯有const operator[]自然也是无法修改内容的。而如果没有明确表明是const的话，编译器一般会选择operator[]版本的。 而在声明函数内为const，不会修改成员变量的时候，实在有一些成员需要修改，那么可以使用mutable关键字（不过感觉怪怪的）。、 另外，如果const和非const版本的函数，内容几乎一致，但是为了const对象的使用，那么只能重新实现，但是为了减少代码的重用，可以使用下面的措施。 1234567891011121314class TextBlock &#123;public: const char &amp;operator[](int idx) const &#123; // ... // ... cout&lt;&lt;\"Const char operator\"&lt;&lt;endl; return info[idx]; &#125; char &amp;operator[](int idx) &#123; cout&lt;&lt;\"char operator\"&lt;&lt;endl; return const_cast&lt;char&amp;&gt;( static_cast&lt;const TextBlock&amp;&gt; (*this)[idx]); &#125;&#125;; 应当注意，上面的代码中第一个const_cast是为了去除const属性，使得返回出char&amp;，而第二个static_cast是为了构造出const TextBlock&amp;类型的对象，上面也提到，对于普通类型的如无明确需要默认会调用普通版本的operator[]，因此需要将对象转换为const的，保证调用const operator[]，避免陷入无限递归。通过两个cast实现了避免代码重用。 条款04：确定对象被使用前已先被初始化RAII是老生常谈的话题了，构造函数的初始化也是C++ class的基础内容，还要注意的是初始化的顺序，首先是base class先于derived class的构造，另外构造函数中，构造的顺序跟class中声明的顺序是一致的（不是构造函数冒号后的顺序），当然如无必要最好还是应该避免构造过程中，相互使用类中的变量。 接下来还有一个问题就是，non-local static对象的使用问题。 如下面代码所示 12345678910111213141516171819202122// FileSystemclass FileSystem &#123;public: ... std::size_t numDisks() const; ...&#125;;extern FileSystem tfs;// Directory class Directory &#123;public: Directory(params); &#125;;Directory::Directory(params) &#123; ... std::size_t disks = tfs.numDisks(); ...&#125;Directory tempDir(params); 因为tfs不一定在tempDir构造之前完成了初始化，它们都是不同编译单元内的non-local static对象，它的初始化相对顺序是未定义的，使用起来会陷入未定义行为的危险当中，而要保证tfs在tempDir之前完成初始化，则需要寻找可确定的初始化顺序。而我们知道，函数中的static变量，在调用函数之前必然会被事先完成初始化，那么就可以利用这一点，将non-local static对象转化为local static对象，进而保证初始化完成，同时，保证只有一个对象。 12345678910111213141516171819202122232425262728// FileSystemclass FileSystem &#123;public: ... std::size_t numDisks() const; ...&#125;;FileSystem&amp; tfs() &#123; static FileSystem fs; return fs&#125;// Directory class Directory &#123;public: Directory(params); &#125;;Directory::Directory(params) &#123; ... std::size_t disks = tfs().numDisks(); ...&#125;Directory&amp; tempDir(params) &#123; static Directory td(params); return td;&#125; 当然了，要保证使用一个对象，返回值必然是引用的，这也是Singleton模式的常见实现方法。思想是：以local static对象替换non-local static对象。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"leetcode(907)","slug":"leetcode-907","date":"2019-02-20T06:28:18.000Z","updated":"2019-02-20T07:19:50.317Z","comments":true,"path":"2019/02/20/leetcode-907/","link":"","permalink":"http://yoursite.com/2019/02/20/leetcode-907/","excerpt":"","text":"leetcode907题，题意很简单，就是计算数组所有的连续子数组的最小值的和。 有两种做法，一种是单调栈，一种是单调队列。 先说单调栈，思路就是找到数组中数字作为子数组最小值的左右边界，然后计算即可。如3 1 2 4，对于1来说，左边界就是最左端，右边界就是最右端，那么1作为最小值的子数组就有2×3个（离左端距离2，右端距离3），类似的，对2来说就是1×2。因此只需要计算得到每个数作为最小值的左右边界，即可完成。而要高效计算左右边界，则引入了单调栈的结构。 单调栈，顾名思义，它首先是一个栈，而且内部是单调有序的。使用单调栈的重要原因是，当我们从左到右，检测数字右边界的过程中，较大数能到达的右边界，那么它左边的较小数也能到达该右边界，因此可以统一处理，而较小数遇到了更小数的时候，较小数就不能继续到达右边界了。即查找右边界的时候，左边的数越小，越能到达该右边界。 计算左边界的思路同理，但是还有一个细节要注意的就是，左右边界的等号处理问题，就是遇到相同的数字的时候，要控制某一边的边界不变，来捕获大数组，而不构成重复，考虑3 1 2 3 1 4，碰到1的时候的处理细节即可。 AC代码： 1234567891011121314151617181920212223242526272829class Solution &#123;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; stack&lt;int&gt; st1, st2; int n = A.size(); vector&lt;int&gt; left(n, -1), right(n, n); for (int i=0;i&lt;n;++i) &#123; while (!st1.empty() &amp;&amp; A[st1.top()] &gt;= A[i]) &#123; right[st1.top()] = i; st1.pop(); &#125; st1.push(i); &#125; for (int i=n-1;i&gt;=0;--i) &#123; while (!st2.empty() &amp;&amp; A[st2.top()] &gt; A[i]) &#123; left[st2.top()] = i; st2.pop(); &#125; st2.push(i); &#125; int ans = 0; for (int i=0;i&lt;n;++i) &#123; ans += (left[i] - i) * (i-right[i]) * A[i]; ans %= 1000000007; &#125; return ans; &#125;&#125;; 时间和空间复杂度为O(n)。 接下来是单调队列的做法。单调队列是我最先想到的方法，但是初始版本的最坏复杂度过高，因此先放下来了。基本思路是这样的，比如说3 1 2 4，从左往右扫的过程中，先碰到3，3自然可以作为一个子数组，得到3，而继续扫的过程中，遇到了1，那么从3开始的数组，若碰到了1，那么接下来的最小值就是1了，另外，从1开始的数组，其子数组的最小值自然也是1，会得到队列1 1，接下来碰到了2，因为2比1小，所以2要作为最小值，只能重新开始作为新的子数组，而1可以继续延续作为子数组，得到队列1 1 2，到了4，队列就变成了1 1 3 4，最终结果就是每一个队列的和的和，这个和可以通过每一次的维护队列过程来进行维护。代码如下： AC代码： 123456789101112131415161718192021222324class Solution &#123;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; vector&lt;int&gt; que; int n = A.size(), sum = A[0]; que.push_back(A[0]); int cnt = 1, cur = A[0]; for (int i=1;i&lt;n;++i) &#123; int j = cnt - 1; while (j &gt;= 0 &amp;&amp; que[j] &gt; A[i]) &#123; cur = cur - que[j] + A[i]; que[j] = A[i]; j--; &#125; cnt++; cur += A[i]; que.push_back(A[i]); sum += cur; cur %= 1000000007; sum %= 1000000007; &#125; return sum; &#125;&#125;; 当然这个算法的最坏复杂度是O(n^2)，自然是不够看的。 实际上，可以发现队列是有序的，因此维护序列的过程中，可以通过二分查找来进行优化，优化之后结果的AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;private: int upperb(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;que, int size, int target) &#123; int left = 0; while (size &gt; 0) &#123; int half = size&gt;&gt;1; int mid = left+half; int idx = que[mid]; if (A[idx] &lt;= target) &#123; left = mid+1; size = size - half - 1; &#125; else &#123; size = half; &#125; &#125; return left; &#125;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); vector&lt;int&gt; que(n), cursum(n); que[0] = 0; cursum[0] = A[0]; int cur = 1, sum = A[0]; for (int i=1;i&lt;n;++i) &#123; int p = upperb(A, que, cur, A[i]); if (p == 0) &#123; cursum[0] = A[i]*(i+1); que[0] = i; cur = 1; &#125; else &#123; cursum[p] = cursum[p-1] + A[i]*(i-que[p-1]); que[p] = i; cur = p+1; &#125; sum += cursum[cur-1]; cursum[cur-1] %= 1000000007; sum %= 1000000007; &#125; return sum; &#125;&#125;; 最坏复杂度是O(nlogn)，不过这是一个比较松的上界，实际表现比上面的单调栈代码快一丢丢。 补充一个二分查找的写法，这里二分查找优化是需要自己写，而不能单纯使用upper_bound这些的，我个人比较喜欢的写法是stl标准库的写法，有个first，size，二分过程中用half，可以自己去查阅文档啦~","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]}]}