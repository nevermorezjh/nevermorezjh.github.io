{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"effective-C++(6)","slug":"effective-C-6","date":"2019-03-18T06:17:27.000Z","updated":"2019-03-18T07:47:52.228Z","comments":true,"path":"2019/03/18/effective-C-6/","link":"","permalink":"http://yoursite.com/2019/03/18/effective-C-6/","excerpt":"","text":"条款32：确定你的public继承塑模出is-a关系public继承中表示类之间的关系是严格的is-a关系，代表基类中所有的函数都适用于继承类，如penguin继承于bird，如果需求中bird需要fly，那么直接public继承于带fly函数的bird是不合适的，同理还有square继承于带单独实现调整width的rectangle也是不合适的，前者的话可以考虑单独的bird，区分flyingbird和penguin这样不飞的bird。所以实际上是否public继承也是取决于需求和业务场景，并需要及时调整。 条款33：避免遮掩继承而来的名称C++的作用域而言，如果一个作用域中找不到合适的函数或者变量，都会往外一层的作用域中寻找。然而，实际上类中并不会这样做，尽管是public继承，在继承类中如果实现了基类某个函数的其他版本（就算是参数不一样），也会把基类的函数覆盖，有时候本以为只是一种重载，添加其他函数来使用，实际上是一种覆盖关系，可能会造成调用过程的报错。解决方法可以在继承类中使用using Base::func，向编译器要求提供某个函数的版本，而当要求的时候不需要指定参数，而是直接把基类的所有版本函数搬过来进行使用，参数相同的话，那就是重载覆盖。 1234567891011121314151617181920212223class Base &#123;public: void func(int x) &#123; cout&lt;&lt;\"Base: \"&lt;&lt;x&lt;&lt;endl; &#125; void func() &#123; cout&lt;&lt;\"Base\"&lt;&lt;endl; &#125; &#125;;class Derived: public Base &#123;public: using Base::func; void func(int x) &#123; cout&lt;&lt;\"Derived: \"&lt;&lt;x&lt;&lt;endl; &#125;&#125;;int main() &#123; Derived x; x.func(10); return 0;&#125; 条款34：区分接口继承和实现继承对于基类的virtual函数，设置成pure virtual往往是比较适合的做法，因为能够防止继承类忘记实现对应的实现而错误地调用了基类的default实现，当然如果确定调用的话，设计成实现继承也无妨。 条款35：考虑virtual函数以外的其他选择当设计基类的某个函数涉及到策略等继承类需要各自实现它们自己的计算方法的时候，不仅仅可以考虑virtual函数方法来实现，还有以下多种方法。 Non-Virtual Interface手法，倾向于将所有的virtual函数定义成private类型的，使用的时候通过同一个public non-virtual函数来进行调用，对客户使用比较友好。但是这种情况下，如果继承类要调用基类型的private virtual function则有麻烦，需要将private的函数改成protected的，来保证继承类能够使用。 Strategy模式，Strategy模式是一种经典的设计模式，最直接的做法就是将virtual函数转化成需要输入函数指针的函数，对于不同的继承类，实现不同的函数，并以指针的方式进行传参和调用，实现了策略和本体的分离，灵活性很强，并且不同的继承类实体还能有不一样的计算函数（传的函数指针不一样即可），并且在运行期可以选择不同的函数指针，调整计算方法。当然这种方法因为不在类中，因此如果要访问类中的元素可能还需要声明为friend函数，但是这种方法也会弱化类的封装，当然用member函数来调用也不是不可以。 更高级一点的做法去实现Strategy模式就是通过类提高封装性，如下面的代码 1234567891011121314151617class GameCharacter; // forward declarationclass HealthCalcFunc &#123;public: ... virtual int calc(const GameCharacter &amp;gc) const &#123; ... &#125; ...&#125;;HealthCalcFunc defaultHeathCalc;class GameCharacter &#123;public: explicit GameCharacter(HealthCalcFunc *phcf = &amp;defaultHealthCalc): pHealthCalc(phcf) &#123;&#125; int healthValue() const &#123; return pHealthCalc-&gt;calc(*this); &#125; ...private: HealthCalcFunc* pHealthCalc;&#125;; 条款36：绝不重新定义继承而来的non-virtual函数如果你是public继承，那么对于non-virtual函数没有理由在一个is-a基类的继承类重新定义它的实现。而且对于non-virtual函数，函数调用时非动态绑定的，使用多态很容易调用错误的函数。 条款37：绝不重新定义继承而来的缺省参数值因为函数的缺省参数值是静态绑定的，就算你是virtual函数，你在继承类重新定义了缺省参数值，使用基类的指针来调用，其缺省参数值必然是基类的参数值。 123456789101112131415161718192021222324252627282930313233class Shape &#123;public: enum ShapeColor&#123;Red, Green, Blue&#125;; virtual void draw(ShapeColor color = Red) const = 0;&#125;;class Rectangle: public Shape &#123;public: virtual void draw(ShapeColor color = Green) const &#123; cout&lt;&lt;\"Rectangle: \"&lt;&lt;color&lt;&lt;endl; &#125;&#125;;class Circle: public Shape &#123;public: virtual void draw(ShapeColor color) const &#123; cout&lt;&lt;\"Circle: \"&lt;&lt;color&lt;&lt;endl; &#125;&#125;;int main() &#123; Shape *ps; Shape *pc = new Circle; Shape *pr = new Rectangle; ps = pc; ps = pr; pc-&gt;draw(Shape::Red); pr-&gt;draw(Shape::Red); pr-&gt;draw(); return 0;&#125; 条款38：通过复合塑模出has-a或“根据某物实现出”在应用域上，复合意味着has-a，在实现域上，复合意味着is-implemented-in-terms-of。 条款39：明智而审慎地使用private继承private继承跟public继承不同，没有办法做到动态调用，因为private继承会把所有基类成员函数转换成private，无法保证函数还能够public调用。另外，private继承能保证的是继承类能够访问到基类的public和protected成员，而private成员将无法访问。 实际上，private继承意味着is-implemented-in-terms-of，跟复合一样，然而它的级别往往比复合要低。好处的地方是，相比起复合来说，不仅能访问public的，更是多了可以访问protected的成员，并且virtual函数也能继承过来，并override它，否则一般而言还是使用复合的处理方法更加合适。还有一个优点是empty base最优化。 条款40：明智而审慎地使用多重继承多重继承上就体现了virtual继承的重要性，但是virtual继承同时也会带来大小，速度，初始化复杂度等成本，如果virtual base classes不带任何数据，那么将是最具实用价值的情况。 多重继承也有正当用途，如“public继承某个interface class”和“private继承某个协助实现的class”的两相结合，但是场景还是相对较少。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"leetcode-975","slug":"leetcode-975","date":"2019-03-12T07:49:15.000Z","updated":"2019-03-12T08:20:08.411Z","comments":true,"path":"2019/03/12/leetcode-975/","link":"","permalink":"http://yoursite.com/2019/03/12/leetcode-975/","excerpt":"","text":"题意很有意思，定义一个操作是奇偶跳跃，第奇数次跳跃，就必须跳往大于等于自己的，并且是往前最近的一个位置，而第偶数次跳跃，就要跳往小于等于自己的，并且是往前最近的一个位置。问，可以从任意一个位置启动，有多少个可以启动到达到最后一个位置的位置。 首先，这是跳跃相关的问题，因此有dp的思路，从一段的跳跃，逐渐扩展到整一段的跳跃。而这题，因为是跳跃到前面自己最靠近的位置，因此必须从后往前dp。如果从前往后dp，会发现后面加入的位置，可能成为前面的点更应该跳跃到的位置，从而导致了dp没有递推性，公式不成立，而从后往前dp就不会有这样的问题。 而第二个问题，就是如何找到自己最靠近的数，也就是跳跃点的寻找，naive的做法自然是$O(n)$去寻找跳跃点，dp扩展的过程中，找新加入位置的跳跃点，然后根据前面dp到的信息，判断它要跳跃的点能不能跳跃到最后一个位置，实现dp，那么有没有更加高效的方法呢？ 有两种，第一种是dp的过程中，维护这样的排序序列，使用堆来进行优化，来找到最接近的位置，而stl库里面正好有map来帮助维护这个结构，接下来就是考察map的使用方法了（这道题考察的还挺全面的，所以记录一下）。 对map来说，它的迭代器是双向的，官方文档描述它的iterator是a bidirectional iterator to value_type（某些博客里没写对），因此可以很方便地找到目标前后的大概位置。 map还有lower_bound和upper_bound函数，顺便学习了一下这两个函数的具体使用场景和方法（其实一直我只会用lower_bound），而map也有专用的两个bound的接口可以直接使用，lower_bound就是找到大于等于自己这个数的最小的索引位置，而upper_bound就是找到大于自己的最小的索引位置（理解应该没问题），所以在这题里面就很简单了，使用lower_bound找到离自己最近的大于等于自己的那个位置，upper_bound加往前的迭代器找到离自己最近的小于等于自己的那个位置，完成$O(log(n))$的查找和维护。 最后dp的思路也很简单，从最后一个点的前一个点开始，看每个点的奇偶跳跃能不能到达最后一个点只要知道它将要跳跃的点能不能到达最后一个点，因为要知道从那一点开始能不能到达最后一个点，也就是第一次跳跃，所以如果它跳往大于等于它的那个位置能够偶数跳跃到最后一个点，那就代表它能够到达最后一个点，而它要经过偶数跳跃调到最后一个点，那它偶数跳跃到的那个点必须能奇数跳跃到最后一个点，正好是$O(n)$的dp，最终复杂度是$O(nlog(n))$ AC代码如下： 123456789101112131415161718192021class Solution &#123;public: int oddEvenJumps(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); vector&lt;bool&gt; even(n, false), odd(n, false); map&lt;int, int&gt; mp; int ans = 1; mp[A[n-1]] = n-1; even[n-1] = odd[n-1] = true; for (int i=n-2;i&gt;=0;--i) &#123; int val = A[i]; auto oddJump = mp.lower_bound(val); auto evenJump = mp.upper_bound(val); if (oddJump != mp.end()) odd[i] = even[oddJump-&gt;second]; if (evenJump != mp.begin()) even[i] = odd[(--evenJump)-&gt;second]; if (odd[i]) ++ans; mp[val] = i; &#125; return ans; &#125;&#125;; 第二种方法就是用到上一篇提到的单调栈结构（应该也是本题的出题目的，毕竟标记了stack的标签）。关键就是如何使用单调栈来获取点的跳跃位置，回想上一题就会发现思路其实几乎是一样的，奇数跳跃就是从小到大排好序，大小一样就按index排序，栈中维护的单调性是index的单调性，当它遇到了index比它后的，那么就代表它将要跳往那一个点了，因为刚好比它大，而且index是最小的，扫一遍即可完成，而排序是$O(nlog(n))$的复杂度。偶数跳跃的思路也一样。结合最后的$O(n)$dp，其实总复杂度也是$O(nlog(n))$，而因为这是一下子排序好了的，因此比上面的维护过程会快一点。 而此处也认识了一个新的知识点，就是vector中用emplace_back的速度是优于push_back的，主要原因是前者只需要一次构造函数，后者还可能还会多一次拷贝构造函数，开销稍微大一点。 AC代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960bool cmp1(const pair&lt;int, int&gt; &amp;lhs, pair&lt;int, int&gt; &amp;rhs) &#123; return lhs.first &gt; rhs.first || (lhs.first == rhs.first &amp;&amp; lhs.second &lt; rhs.second);&#125;bool cmp2(const pair&lt;int, int&gt; &amp;lhs, pair&lt;int, int&gt; &amp;rhs) &#123; return lhs.first &lt; rhs.first || (lhs.first == rhs.first &amp;&amp; lhs.second &lt; rhs.second);&#125;class Solution &#123;public: int oddEvenJumps(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); vector&lt;pair&lt;int, int&gt;&gt; vec; for (int i=0;i&lt;n;++i) &#123; vec.emplace_back(A[i], i); &#125; sort(vec.begin(), vec.end(), cmp2); vector&lt;int&gt; oddNext(n, -1); stack&lt;pair&lt;int, int&gt;&gt; st; st.push(vec[0]); for (int i=1;i&lt;n;++i) &#123; auto p = vec[i]; while (!st.empty() &amp;&amp; st.top().second &lt; p.second) &#123; oddNext[st.top().second] = p.second; st.pop(); &#125; st.push(p); &#125; sort(vec.begin(), vec.end(), cmp1); vector&lt;int&gt; evenNext(n, -1); stack&lt;pair&lt;int, int&gt;&gt;().swap(st); st.push(vec[0]); for (int i=1;i&lt;n;++i) &#123; auto p = vec[i]; while (!st.empty() &amp;&amp; st.top().second &lt; p.second) &#123; evenNext[st.top().second] = p.second; st.pop(); &#125; st.push(p); &#125; int ans = 1; vector&lt;bool&gt; oddJump(n, false), evenJump(n, false); oddJump[n-1] = evenJump[n-1] = 1; for (int i=n-2;i&gt;=0;--i) &#123; int evennext = evenNext[i], oddnext = oddNext[i]; if (evennext != -1 &amp;&amp; oddJump[evennext]) &#123; evenJump[i] = true; &#125; if (oddnext != -1 &amp;&amp; evenJump[oddnext]) &#123; ans += 1; oddJump[i] = true; &#125; &#125; return ans; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"effective-C++(5)","slug":"effective-C-5","date":"2019-03-11T12:06:44.000Z","updated":"2019-03-11T12:57:07.957Z","comments":true,"path":"2019/03/11/effective-C-5/","link":"","permalink":"http://yoursite.com/2019/03/11/effective-C-5/","excerpt":"","text":"条款26：尽可能延后变量定义式的出现时间延后变量定义的时间考虑的点有两个，一个是防止变量没有用上，就陷入了异常当中，导致变量构造和析构的不必要开销，另一个则是出于RAII的考虑，不应当无内容地构造一个变量，需要用到的时候再创建出来即可，代码优美，可读性高。 还有一个考虑的场景是循环内的变量，应该在循环内需要用到再构造还是在循环外先构造好，减少析构函数的开销，其实根据条款来说自然是倾向于在循环内构造，因为循环外构造会遇到的问题就是变量的作用域变大了，不够美观和安全的同时，也出现了没有凭空构造对象的状况（个人觉得，这种代码也有点不够美观…），当然，如果是在效率要求比较高的代码环境下，在循环外定义还是有一定的意义的，而且变量作用域的问题也可以直接添加一个大括号作为scope来解决。 条款27：尽量少做转型操作C风格的转型动作也成为旧式转型，主要如下 12(T)expression;T(expression); 而C++则提供多了其余四种转型类型 1234const_cast&lt;T&gt;(expression);dynamic_cast&lt;T&gt;(expression);reinterpret_cast&lt;T&gt;(expression);static_cast&lt;T&gt;(expression); C++中运用新型转型的意义有两个，一个是代码辨识度高，容易区别出哪些地方出现了类型系统问题，第二个则是各类型动作的目标窄化，有利于编译器和人为判断出出错位置。 对于C风格的旧型转型，作者更加倾向于只在需要explicit构造的函数中使用，其余地方均使用C++的转型类型。 而下面有几个需要注意的问题。 第一个是对于某些平台上（如嵌入式平台），继承类的对象指针跟基类的对象指针有一定的偏移量，但是某些平台上（如pc）则没有这种偏移量（undefined behavior）。如下面的代码 1234class Base &#123;...&#125;class Derived: public Base &#123;...&#125;;Derived d;Base *pb = &amp;d; 此时出现了一定的类型转换，而对于习惯偏移量的程序员来说，如果过于对自己过于自信，直接添加偏移量来获得Derived类的指针位置，则必然导致错误。 第二个则是自作聪明地写出了似是而非的代码。如下面的代码中，static_cast&lt;Base&gt;(*this).incAndGetVal();，看似调用的是基类型的函数，但是如果深入到构造的过程就会发现，类型转换的过程中出现了拷贝构造行为，也就是说类型转换过程包含了拷贝构造的过程，调用的函数也是调用拷贝的对象的函数，那么如果程序员这时候以为自己调用的是本对象的成员函数，以为成功对本对象的成员进行了操作，那么则会导致比较难以察觉的错误，正确的方法则是直接调用基类域中的函数即可Base::incAndGetVal()。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Base &#123;private: int val;public: Base(int v): val(v) &#123; cout&lt;&lt;\"Base constructor\"&lt;&lt;endl; &#125; Base(const Base &amp;rhs): val(rhs.val) &#123; cout&lt;&lt;\"Base copy constructor\"&lt;&lt;endl; &#125; virtual int incAndGetVal() &#123; val++; return val; &#125; virtual ~Base() &#123; cout&lt;&lt;\"Base deconstructor\"&lt;&lt;endl; &#125;&#125;;class Derive: private Base &#123;public: Derive(int v): Base(v) &#123; cout&lt;&lt;\"Derived constructor\"&lt;&lt;endl; &#125; Derive(const Derive &amp;rhs): Base(rhs) &#123; cout&lt;&lt;\"Derived copy constructor\"&lt;&lt;endl; &#125; virtual int incAndGetVal() &#123; return static_cast&lt;Base&gt;(*this).incAndGetVal(); &#125; ~Derive() &#123; cout&lt;&lt;\"Derived deconstructor\"&lt;&lt;endl; &#125;&#125;;int main() &#123; Derive test(10); cout&lt;&lt;test.incAndGetVal()&lt;&lt;endl; cout&lt;&lt;test.incAndGetVal()&lt;&lt;endl; return 0;&#125; 还有就是注意dynamic_cast的调用，因为这种调用的成本很高，会在运行的过程中反复调用strcmp函数，来找到你要转换成的继承对象，进而通过基类指针调用到你想调用的继承类对象的成员函数。如果可以，把变量直接声明成对应的继承类型即可，减少了运行期的开销。 条款28：避免返回handles指向对象内部部分为了提高类的封装性，自然是要避免返回handles（包括references，指针，迭代器等）指向对象内部，并且帮助const成员对象的行为像个const（记得什么时候要返回const类型），并防止dangling handles（因为返回对象会马上被析构，指针指向它自然就dangling了）。 条款29：为“异常安全”而努力是值得的异常安全需要保证两个方面，第一个是不泄露任何资源（抛出异常的时候保证所有资源能够被正常析构），第二个则是不允许数据破坏（抛出异常的时候要保证数据操作正确，不受异常影响）。 三个保证，基本承诺（没有对象数据被损坏），强烈保证（跟调用出现异常的函数之前一模一样），不抛掷保证（nothrow）。 下面是简单的copy and swap策略介绍。 123456789101112131415161718struct PMImpl &#123; shared_ptr&lt;Image&gt; bgImage; int imageChanges;&#125;;class PrettyMenu &#123;private: Mutex mutex; shared_ptr&lt;PMImpl&gt; pImpl;&#125;;void PrettyMenu::changeBackground(std::istream&amp; imgSrc) &#123; using std::swap; Lock ml(&amp;mutex); shared_ptr&lt;PMImpl&gt; pNew(new PMImpl(*pImpl)); pNew-&gt;bgImage.reset(new Image(imgSrc)); ++pNew-&gt;bgImage.imageChanges; swap(pImpl, pNew);&#125; 这里主要防止了构造新的pImpl的过程中抛出异常，导致原来的pImpl的数据出现问题，而且作为指针，swap的开销也并不高，当然这种策略的应用范围也有一定的条件限制，因此还需要特殊情况特殊分析。 条款30：透彻了解inlining的里里外外inline函数背后提高效率的优化概念就是，将每个调用的函数，都以函数的本体来代替，那么如果这样的函数过于频繁地被多处调用，那么将会导致代码膨胀的问题。考虑操作系统的概念，操作系统都会把要运行的代码放到一块内存当中，并采用分页的管理方法，那么如果代码过于膨胀，这样的inline函数会导致程序执行的过程中进行频繁的换页行为，这些损失可以说是得不偿失的。 而隐式inline的地方更多是在类当中，如果函数直接在类中的声明中实现了，像我上面的Base一样，将会默认是inline函数，而要知道，编译器是会为类生成构造函数，析构函数等函数的，如果直接在类中实现或是不实现，都会导致过多的inline函数，产生了不易发现的效率影响。 另外，inline函数一般也无法取得函数指针（因为编译器只是按代码段来看待）。所以需要函数指针时，编译器可能会拒绝inline。 条款31：将文件间的编译依存关系降至最低善用handle classes和interface classes。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"effective-C++(4)","slug":"effective-C-4","date":"2019-03-05T03:25:19.000Z","updated":"2019-03-05T06:52:05.715Z","comments":true,"path":"2019/03/05/effective-C-4/","link":"","permalink":"http://yoursite.com/2019/03/05/effective-C-4/","excerpt":"","text":"条款18：让接口容易被正确使用，不易被误用本条款精髓在一个先发制人，也就是说，接口设计者会对接口进行特别的设计，来保证接口使用者按照一定规则来使用接口，避免误用，提高可读性，提高bug定位的速度。 举个例子，如下面的日期类构造函数。 123456class Date &#123;public: Date(int month, int day, int year);&#125;;Date d(5, 3, 1995); 上述代码中，使用者或者reviewer不一定能发现是5月3日还是3月5日，甚至出bug的时候也不容易发现这小细节（虽然是可以在构造函数中构建日志…）但是更直接地提高可读性的方法是增加识别的wrapper，开销不大，但是可读性大大增加了。 12345678910111213141516171819struct Day &#123; explicit Day(int d): val(d) &#123; &#125; // 注意explicit int val&#125;;struct Month &#123; explicit Month(int d): val(d) &#123; &#125; int val&#125;;struct Year &#123; explicit Year(int d): val(d) &#123; &#125; int val&#125;;class Date &#123;public: Date(const Day &amp;d, const Month &amp;m, const Year &amp;y); ...&#125;;Date d(Day(5), Month(3), Year(1995)); 还有的解决方法是用类静态函数 1234567891011class Month &#123;public: static Month Jan() &#123; return Month(1); &#125; static Month Feb() &#123; return Month(2); &#125; ...private: explicit Month(int m): val(m) &#123;&#125; int val;&#125;Date d(Month::Mar(), Day(5), Year(1995)); 当然这种方法仅限于项数比较少的情况下，比较通用的还是上面struct的类型，也已经足够使用了。用类静态函数方法有两个注意点，一个是跟enum的区别，enum的类型安全性不足（能够当作int类型来使用)，第二个是构造函数是private的，也就是说，只能通过类静态函数获得月份。 接下来继续推销shared_ptr，因为shared_ptr能够直接管理好资源，并定制删除器，能够使用户省去很多不安全的操作，同时也更加的安全，如“跨DLL的new/delete成对运用”是会可能是会导致运行错误的（因为new/delete使用的是局部堆，也就是说不同的DLL虽然共享一个地址空间，但完全可能会维护不同的局部堆（堆分段），这与编译器的实现有关。有些编译器可以选择使用进程共享的局部堆，但性能会受影响。如果是不同的局部堆，当你在DLL中new时，是在DLL的堆中分配的，而当你在EXE中delete时，EXE会认为它是在EXE的局部堆中分配的，从而用EXE的堆信息去释放它，从而可能导致错误。具体情况与堆管理代码的实现有关。），而使用shared_ptr的删除器则是来自本身的DLL，因此能够更加安全。 条款19：设计class犹如设计type设计class需要考虑的问题包括但不限于，构造，赋值，传递操作，类型转换，继承，定义操作符，是否需要template等等。 条款20：宁以pass-by-reference-to-const替换pass-by-value对类减少拷贝构造函数，析构函数等开销。当然对基本类型和STL的来说，pass-by-value的得到了不少的优化，因此开销并不贵（比说说印象中，string中使用的写时拷贝技术）。 条款21：必须返回对象时，别妄想返回其reference不要搞返回local变量，静态变量的static，拷贝构造开销比出问题的时候带来的难题低太多了，除非如条款04那样，你知道你在做什么。 条款22：将成员变量声明为private无论是protected还是public，都降低了类的封装性，protected看似封装，但是对于继承类来说，其实封装性也是有不少的降低的。封装性带来的是代码修改维护的高效，因为对于直接public的成员，如果直接使用了，那么代码需要修改的地方则不仅仅是类，还包括了其他使用到了该public变量的地方。对protected成员也一样，对于继承类使用到的地方也是要逐一检查修改的。 条款23：宁以non-member、non-friend替换member函数同理，不必要地增加member函数，也使得类更加的臃肿，当non-member、non-friend函数能够实现的时候，也意味着该函数没必要作为member函数，提高封装性，也保留了扩展性。 条款24：若所有参数皆需类型转换，请为此采用non-member函数如有理数类与整数的乘法。 1234class Rational &#123; ... &#125;result = onehalf*2;result = 2*onehalf; 如果直接使用成员函数，那么会导致2*onehalf的错误，原因是int类型并没有乘以Rational的成员函数，同时也无法进行隐式转换。因此最能直接解决问题的是使用non-member函数，这写non-member函数的过程中就能够考虑好各种方面的。当然，根据上面的条款，能不使用friend函数就不使用。 条款25：考虑写出一个不抛异常的swap函数此处需要了解C++的模板特化与模板偏特化，还有一个地方需要的就是，不要试图全特化std的function template，因为这是未定义的行为，如 1234567891011121314151617181920212223242526272829303132333435template&lt;typename T&gt;class A &#123;public: A(int x): val(x) &#123; cout&lt;&lt;\"Construct\"&lt;&lt;endl; &#125; A(const A&amp; rhs): val(rhs.val) &#123; cout&lt;&lt;\"Copy Construct\"&lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;\"Deconstruct\"&lt;&lt;endl; &#125; const int get() const &#123; return val; &#125; void swap(A&amp; rhs) &#123; using std::swap; swap(this-&gt;val, rhs.val); &#125;private: T val;&#125;;namespace std &#123; template&lt;typename T&gt; void swap(A&lt;T&gt; &amp;rhs, A&lt;T&gt; &amp;lhs) &#123; cout&lt;&lt;\"Specialization\"&lt;&lt;endl; rhs.swap(lhs); &#125;&#125; 虽然代码简单而且运行起来并不会发现什么问题，但是实际上这样std::swap template全特化的过程是未定义行为，应该予以避免（如果去掉template的话，却是及格的偏特化)。最直接的用户应当是在另外的namespace中完成偏特化，然后在后续当中使用using std::swap，让编译器自己去选择最合适的swap函数。 此处，也可以得知std中swap的实现方法，类似于 123456template&lt;typename T&gt;void swap(T &amp;a, T &amp;b) &#123; T temp(a); a = b; b = a;&#125; 使用了一次拷贝构造函数和两次赋值函数以及一次的析构函数，达到安全的效果。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"effective-C++(3)","slug":"effective-c-3","date":"2019-03-04T02:08:10.000Z","updated":"2019-03-05T03:26:27.574Z","comments":true,"path":"2019/03/04/effective-c-3/","link":"","permalink":"http://yoursite.com/2019/03/04/effective-c-3/","excerpt":"","text":"条款13：以对象管理资源这一章基本都是推销智能指针， 以及讲智能指针可能需要注意的事情，但是稍微比较老了，还在讲auto_ptr的事情，印象中，C++11就已经废除了auto_ptr，只有unique_ptr，shared_ptr，weak_ptr三种指针了，因此后面还要补充一下这三种指针的实现，使用场景，还有具体为什么废除auto_ptr的原因，等等的关于智能指针的内容（希望记得）。 这里就讲到了一个很重要的概念，Resource Acquisition Is Initialization(RAII)，意思就是资源取得的时机也是它初始化的时间，在C++中，就需要很好地管理好变量的生命周期，防止return，exception等的出现，导致delete无法执行，进而导致资源泄露。那么解决方法就需要注意到，对于new的变量需要delete之外，作用域内声明的其它变量，都会被自动执行析构函数，因此就有了使用对象来管理资源的概念，对于new来说，自然可以实现一个智能的指针来实现资源的管理，当退出该作用域的时候，能够自动调用其析构函数，把资源还回去。 而使用智能指针的开始，需要注意的是，智能指针内执行的删除器一般来说（最起码是默认的），都是执行delete，而非delete []，所以交入智能指针的不要是new []的指针。 条款14：在资源管理类中小心copying行为当用智能指针管理指针的时候，可以考虑的问题（或者说好处）就多了起来，比如说复制的行为，一般来说有几种选择的可能。 禁止复制，就是私继承uncopyable。 对底层资源祭出“引用计数大法“，这也是shared_ptr实现的技术原理，能够保证使用的是同一个指针，保证资源能够被正确地释放，保证资源被释放之后不会被错误地使用，这都是通过”引用计数“这项技术来实现的。 复制底部资源，直接deep-copy，复制出一份一模一样的出来，当然，这一份只是一模一样，从逻辑上来讲，复制品指向的地方不一样了，复制品对进行修改的话，并不能修改原件。 转移底部资源的拥有权，像auto_ptr那样，直接转移使用权，原指针指向的地方变为空了（容易出错）。 条款15：在资源管理类中提供对原始资源的访问要能够对原始资源能够进行访问的原因是，可能有些函数，输入的参数需要是原始资源类型的，而非智能指针类型的，这时候就需要通过RAII class的API实现，一般来说有显示转换和隐式转换两种，显示转换是通过get API来实现的，而隐式转换则可以通过operator()来实现，究竟哪种方式比较合适，则是后面条款18考虑的问题。 条款16：成对使用new和delete时需要采用相同形式即new和delete配对，new []和delete []配对，否则将会产生未定义行为，很可能导致资源泄露。 条款17：以独立语句将newed对象置于智能指针假若有个场景是要求使用如下的代码的： 12int priority();void processWidget(std::tr1::shared_ptr&lt;Widget&gt; pw, int priority); 如果使用的方式是如下这样的： 1processWidget(new Widget, priority); 会导致问题，因为智能指针的构造函数是explicit的。 而这种实现方法1processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority()); 也会导致问题，因此priority的执行时间并不一定，不能保证执行顺序。如果是执行了new Widget之后再执行priority()，最后再放入shared_ptr中的话，那么如果priority()抛出异常，则会导致资源泄露。问题的原因在于函数中的comma operator在这里是作为sequence point，虽然a, b, c是保证按顺序执行的，但是在函数中func(arg1, arg2, arg3)的顺序则是未定义的，因此可能会出现那样的问题。最直接的改变方法就是如下 12std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget); // RAIIprocessWidget(pw, priority()); // 其实我看priority这样调用也不是很舒服（ 总的来说，反映出来要注意的问题就是new出来的对象，一定要保证把它能够立即交给智能指针管理，否则就会有隐患。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"effective-C++(2)","slug":"effective-C-2","date":"2019-02-25T06:29:22.000Z","updated":"2019-03-04T03:14:40.957Z","comments":true,"path":"2019/02/25/effective-C-2/","link":"","permalink":"http://yoursite.com/2019/02/25/effective-C-2/","excerpt":"","text":"条款05：了解C++默默编写并调用哪些函数一个完整的C++类，必然包含了构造函数，析构函数，copy构造函数，copy assignment操作符函数，如果没有写这些函数，那么编译器将会生成default版本的函数，大致来说，隐患主要来源于copy构造函数，copy assignment操作符函数过于暴力。默认版本的这两个函数都会直接将rhs的值粗暴地用等号赋值起来，那么对于const的成员，显然会直接报错，另外，对于引用值来说，也是一个很难发现的隐患，因为引用是不可以修改的，如下面的代码 12345string a = \"10\", b = \"1\";string &amp;c = a;cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;\" \"&lt;&lt;c&lt;&lt;endl;c = b;cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;\" \"&lt;&lt;c&lt;&lt;endl; 看意思似乎是将c更改为b的引用，然而实际上只会修改a的值为b，最终使得c仍为a的引用，然而a的值却改变成了b的值。在这简短的代码中，或许比较容易发现，然而在一段较复杂的类代码中，往往是个不容易发现的隐患。 解决这些隐患的方法有两个，第一个是养成自己书写这些会默认生成的函数的习惯，毕竟在简单的类中，实现这些代码并不费多少功夫，而在大的类当中，自然是必不可少的一环，减少bug的隐患。另外一个则是不需要这些函数的时候，将这些函数声明成private，并且只声明不实现，声明为private可以防止用户错误地使用这些有隐患的函数，只声明不实现能防止继承类中使用到这些不需要的函数。 条款06：若不想使用编译器自动生成的函数，就该明确拒绝正如上面所说，编译器为类自动生成的函数有不小的风险，当不需要的时候需要明确地拒绝编译器默认生成，阻止用户使用。在这个过程中，细节有两个，一个是只声明不实现，报错实际上是由编译器报错，而声明为private则是可以在连接器中报错，阻止member函数或friend函数对其进行使用。 而要把连接期的错误移到编译期报错是可以实现的（提早报错是好事），只需要实现一个不可复制的基类即可。 123456789101112131415class Uncopyable &#123;private: Uncopyable(Uncopyable&amp;); Uncopyable&amp; operator=(Uncopyable&amp;);public: Uncopyable() &#123; &#125; ~Uncopyable() &#123; &#125; &#125;;class Customer: private Uncopyable &#123;private: int id;public: Customer(int x): id(x) &#123;&#125;&#125;; 此处有几个可以注意一下的点。 Uncopyable的大小。尽管Uncopyable没有任何成员，sizeof(Uncopyable)仍然为1，因为class和struct的大小都应该大于零。实际上也有一种方法能够实现大小为0的类，就是添加一个大小为0的数组成员，如char s[0]，印象中方法是来自于陈硕的那本muduo。（晚点将该处的解释补上来） 尽管Uncopyable的大小为1，但是其派生类的大小会被编译器优化，如上述代码中Customer的大小就被优化成4了，即一个int的大小。 多重继承下，有些编译器不一定会把Uncopyable的大小优化到最优，但是往往会报warning：direct base ‘Uncopyable’ inaccessible in ‘XXX’ due to ambiguity。 Uncopyable的析构函数作为基类，不需要为virtual的原因是，它并不是作为多态基类的。（加了virtual函数的类的大小以后再深入讨论。） 条款07：为多态基类声明virtual析构函数因为使用多态的时候，需要类真正找到自己合适的析构方法，析构中正确地释放内存，防止内存泄漏或是触碰到不该碰的内存中，所以需要virtual的析构函数，通过virtual指针找到对应的析构函数（跟多态中的其他函数类似）。 而对于本来就不打算作为多态的base class，那么就不应该声明其析构函数为virtual，徒增占用空间。 条款08：别让异常逃离析构函数对于类来说，如果析构的过程中容易抛出异常，这时候就只有两种处理方法，一种是“吞掉异常”，不处理，往往会导致内存泄漏，一种则是“终止进程”，这往往是处理这种异常可取的方法。 然而，无论哪一种方法，都给程序带来了不小的风险，更合适的做法是用户在析构函数外，就将有异常风险的部分处理好，不要试图等到析构过程中出现异常再来处理。 条款09：绝不在构造和析构过程中调用virtual函数当了解了C++类的内存分布，以及构造过程之后就会了解比较深。主要原因就是virtual函数的调用是需要指针指向位置的，在无论是构造过程还是析构过程，都不能完全保证在调用之前，正确的函数指针已经构造完毕或是尚未析构，因此调用将会带来巨大的隐患。 条款10：令operator=返回一个reference to *this可以参考以下的两段代码： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class A &#123;public: A() &#123; cout&lt;&lt;\"Construct\"&lt;&lt;endl; &#125; A(const A&amp; rhs) &#123; cout&lt;&lt;\"Copy Construct\"&lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;\"Deconstruct\"&lt;&lt;endl; &#125; A operator=(const A&amp; rhs) &#123; return *this; &#125;&#125;;int main () &#123; A a, b, c; a = b = c; return 0;&#125; 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class A &#123;public: A() &#123; cout&lt;&lt;\"Construct\"&lt;&lt;endl; &#125; A(const A&amp; rhs) &#123; cout&lt;&lt;\"Copy Construct\"&lt;&lt;endl; &#125; ~A() &#123; cout&lt;&lt;\"Deconstruct\"&lt;&lt;endl; &#125; A&amp; operator=(const A&amp; rhs) &#123; return *this; &#125;&#125;;int main () &#123; A a, b, c; a = b = c; return 0;&#125; 计算构造函数，拷贝构造函数，析构函数的使用次数，即可知道返回reference to *this会造成的资源浪费了。 条款11：在operator=中处理“自我赋值”先看一种很危险的赋值方法： 12345Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125; 考虑一下如果是自我赋值的话，那么这段代码会将自己给删除了，然后重新赋值，导致指针指向了一个被删除的对象。 再看一种比较危险的处理方法： 1234567Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; if (this == &amp;rhs) return *this; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125; 因为此处先删除了pb，再new bitmap，如果new的过程中因为内存不足等原因出现了异常，那么pb仍然指向了一个被删除的空间，看似安全，实际上没有避免掉本质问题，并非异常安全的。 接下来看安全的下实现版本： 123456Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; Bitmap* pOrig = pb; pb = new Bitmap(*rhs.pb); delete pOrig; return *this;&#125; 显然，这个版本直接处理了不安全的部分，是一种行得通的方法，只是效率并不高。 接下来是比较高效的实现方法，使用了copy and swap技术（异常安全技术）。 12345Widget&amp; Widget::operator=(const Widget &amp;rhs) &#123; Widget temp(rhs); swap(rhs); return *this;&#125; 这种技术首先制作了一份副本，然后跟原数据进行了交换，保证了自我赋值正确的同时，确保了异常安全。 更进一步还有这种实现方法： 1234Widget&amp; Widget::operator=(Widget rhs) &#123; swap(rhs); return *this;&#125; 实际上只是把制作副本的过程放到了参数构造中，让编译器可以生成更加高效的代码。 条款12：复制对象时勿忘其每一个成分复制对象的时候不仅要将本类的成员完成好拷贝，对于基类的成员也要保证拷贝完全，实现方法很简单，就是调用其基类的赋值函数。 123456789PriorityCustomer::PriorityCustomer(const PriorityCustomer &amp;rhs): Customer(rhs), priority(rhs.priority) &#123; &#125;PriorityCustomer&amp; PriorityCustomer::operator=(const PriorityCustomer &amp;rhs) &#123; Customer::operator=(rhs); priority = rhs.priority; return *this;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"effective C++(1)","slug":"effective-c-1","date":"2019-02-22T02:13:28.000Z","updated":"2019-03-11T09:23:28.559Z","comments":true,"path":"2019/02/22/effective-c-1/","link":"","permalink":"http://yoursite.com/2019/02/22/effective-c-1/","excerpt":"","text":"条款01： 视C++为一个语言联邦简单来说，就是四个次语言，C，object-oriented C++，template C++， stl。 实际上，入门C++很多年了，而且也不是第一次看effective c++了，现在借此博客来重新阅读学习一遍，并做一些总结。 条款02：尽量以const，enum，inline替换#define不使用#define的原因，主要可以用“宁可以编译器替换预处理器”来解释，就是说，#define的内容可能被预处理器直接替代，编译器并无法看到实际编程使用的记号，那么报错的时候将直接使用替代的元素，代码可读性可能没什么区别，但是编译报错之后可能很难定位bug的位置，毕竟当代码量变大的时候，很难回想起一个替换值的意义是什么，因此必要的时候，对于数值等内容可以使用const和enum来替代。 另外，使用#define来定义一些简短的函数，如#define CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))，当变得复杂，涉及到CALL_WITH_MAX(++a, b)的时候，几乎无法确定(a)被执行了多少次也影响了最终的结果，不加括号的话甚至有可能影响代码的执行顺序，当然这样的代码写法实属取不得，但是也暴露了 #define写法在替代过程中的危险性。要保留简短和高效性，不如使用inline函数。 同时，#define也拥有全局的特性，一旦定义，除非#undef，否则它将一直存在。如果想要具有局部性，有特定的使用区域，那么有两种方法： 使用static const。注意的是，如果需要取该变量的特定地址，就需要在实现文件（语法上可以在头文件，但是推荐是在实现文件）中定义声明一遍。（还有一种需要的可能是编译器（不正确地）需要。），如 12345678910// GamePlayer.hppclass GamePlayer &#123;private: static const int NumTurns = 5; int scores[NumTurns];&#125;;// Gameplayer.cppconst int GamePlayer::NumTurns = 5; 使用enum hack，这种方法更接近于#define，同时也有特定的指定范围，但是它并不能像const那样取得常量的地址，而相当于#define的记号，并不分配内存，而且编译错误中的报错并不像#define那样模糊。缺点在于enum必须是整型常数，对于浮点数或者是其他还是得老老实实使用const，应当注意到enum hack也是模板元编程中会使用的常用技巧之一，以后会说到。 123456789// GamePlayer.hppclass GamePlayer &#123;private: enum &#123; NumTurns = 5, another &#125;; int scores[NumTurns];&#125;; 条款03：尽可能使用const先来区分一下const老题目 12345char greeting[] = \"hello\";const char *p1 = greeting; // 非常量指针，常量数据，数据不可更改char* const p2 = greeting; // 常量指针，非常量数据，指针指向不可更改char const *p3 = greeting; // 非常量指针，常量数据，数据不可更改const char* const p4 = greeting; //常量指针，常量数据，都不可更改 现在首先讲到const返回对象，这个主要是防止使用函数的过程中出现误操作。如 123456789class Rational &#123;...&#125;;const Rational operator* (const Rational &amp;lhs, const Rational &amp;rhs);...Rational a, b, c;if (a * b = c) &#123; ...&#125; 上述例子中本来用来判断的==，写成了赋值，如果不是const类型，那么仍然能够通过编译，因为返回的是一个左值（如果返回int这些基本类型的，作为右值的，那么将会报错），而使用了const之后，因为是一个常量，赋值则会报错，进而避免了这种低级错误。而实际使用方面，如果需要赋值，尽管返回的是const，因为copy assignment函数的存在，因此并不会被影响，当然使用auto的话则需要注意一下了。（auto在此处也不应该这样贸然使用吧。） 接着是const成员函数，如下面的代码 12345678910111213141516171819202122232425262728293031class Text &#123;private: static const int another_size = 15; enum &#123; size = 10, another &#125;; char info[size];public: Text(const char p[]) &#123; int i=0; while (p[i] &amp;&amp; i &lt; size) &#123; info[i] = p[i]; i++; &#125; cout&lt;&lt;another_size&lt;&lt;endl; &#125; Text(const Text &amp;rhs) &#123; for (int i=0;i&lt;size;++i) &#123; info[i] = rhs.info[i]; &#125; &#125; const char &amp;operator[](int idx) const &#123; cout&lt;&lt;\"Const char operator\"&lt;&lt;endl; return info[idx]; &#125; char &amp;operator[](int idx) &#123; cout&lt;&lt;\"char operator\"&lt;&lt;endl; return info[idx]; &#125;&#125;; 对于operator[]函数，要实现两个版本的原因有两个，一个是对于const对象来说，如果没有const函数，那么将无法使用operator[]函数，因为可能涉及到修改，而若单纯有const operator[]自然也是无法修改内容的。而如果没有明确表明是const的话，编译器一般会选择operator[]版本的。 而在声明函数内为const，不会修改成员变量的时候，实在有一些成员需要修改，那么可以使用mutable关键字（不过感觉怪怪的）。 另外，如果const和非const版本的函数，内容几乎一致，但是为了const对象的使用，那么只能重新实现，但是为了减少代码的重用，可以使用下面的措施。 1234567891011121314class TextBlock &#123;public: const char &amp;operator[](int idx) const &#123; // ... // ... cout&lt;&lt;\"Const char operator\"&lt;&lt;endl; return info[idx]; &#125; char &amp;operator[](int idx) &#123; cout&lt;&lt;\"char operator\"&lt;&lt;endl; return const_cast&lt;char&amp;&gt;( static_cast&lt;const TextBlock&amp;&gt; (*this)[idx]); &#125;&#125;; 应当注意，上面的代码中第一个const_cast是为了去除const属性，使得返回出char&amp;，而第二个static_cast是为了构造出const TextBlock&amp;类型的对象，上面也提到，对于普通类型的如无明确需要默认会调用普通版本的operator[]，因此需要将对象转换为const的，保证调用const operator[]，避免陷入无限递归。通过两个cast实现了避免代码重用。 条款04：确定对象被使用前已先被初始化RAII是老生常谈的话题了，构造函数的初始化也是C++ class的基础内容，还要注意的是初始化的顺序，首先是base class先于derived class的构造，另外构造函数中，构造的顺序跟class中声明的顺序是一致的（不是构造函数冒号后的顺序），当然如无必要最好还是应该避免构造过程中，相互使用类中的变量。 接下来还有一个问题就是，non-local static对象的使用问题。 如下面代码所示 12345678910111213141516171819202122// FileSystemclass FileSystem &#123;public: ... std::size_t numDisks() const; ...&#125;;extern FileSystem tfs;// Directory class Directory &#123;public: Directory(params); &#125;;Directory::Directory(params) &#123; ... std::size_t disks = tfs.numDisks(); ...&#125;Directory tempDir(params); 因为tfs不一定在tempDir构造之前完成了初始化，它们都是不同编译单元内的non-local static对象，它的初始化相对顺序是未定义的，使用起来会陷入未定义行为的危险当中，而要保证tfs在tempDir之前完成初始化，则需要寻找可确定的初始化顺序。而我们知道，函数中的static变量，在调用函数之前必然会被事先完成初始化，那么就可以利用这一点，将non-local static对象转化为local static对象，进而保证初始化完成，同时，保证只有一个对象。 12345678910111213141516171819202122232425262728// FileSystemclass FileSystem &#123;public: ... std::size_t numDisks() const; ...&#125;;FileSystem&amp; tfs() &#123; static FileSystem fs; return fs&#125;// Directory class Directory &#123;public: Directory(params); &#125;;Directory::Directory(params) &#123; ... std::size_t disks = tfs().numDisks(); ...&#125;Directory&amp; tempDir(params) &#123; static Directory td(params); return td;&#125; 当然了，要保证使用一个对象，返回值必然是引用的，这也是Singleton模式的常见实现方法。思想是：以local static对象替换non-local static对象。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"leetcode(907)","slug":"leetcode-907","date":"2019-02-20T06:28:18.000Z","updated":"2019-02-20T07:19:50.317Z","comments":true,"path":"2019/02/20/leetcode-907/","link":"","permalink":"http://yoursite.com/2019/02/20/leetcode-907/","excerpt":"","text":"leetcode907题，题意很简单，就是计算数组所有的连续子数组的最小值的和。 有两种做法，一种是单调栈，一种是单调队列。 先说单调栈，思路就是找到数组中数字作为子数组最小值的左右边界，然后计算即可。如3 1 2 4，对于1来说，左边界就是最左端，右边界就是最右端，那么1作为最小值的子数组就有2×3个（离左端距离2，右端距离3），类似的，对2来说就是1×2。因此只需要计算得到每个数作为最小值的左右边界，即可完成。而要高效计算左右边界，则引入了单调栈的结构。 单调栈，顾名思义，它首先是一个栈，而且内部是单调有序的。使用单调栈的重要原因是，当我们从左到右，检测数字右边界的过程中，较大数能到达的右边界，那么它左边的较小数也能到达该右边界，因此可以统一处理，而较小数遇到了更小数的时候，较小数就不能继续到达右边界了。即查找右边界的时候，左边的数越小，越能到达该右边界。 计算左边界的思路同理，但是还有一个细节要注意的就是，左右边界的等号处理问题，就是遇到相同的数字的时候，要控制某一边的边界不变，来捕获大数组，而不构成重复，考虑3 1 2 3 1 4，碰到1的时候的处理细节即可。 AC代码： 1234567891011121314151617181920212223242526272829class Solution &#123;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; stack&lt;int&gt; st1, st2; int n = A.size(); vector&lt;int&gt; left(n, -1), right(n, n); for (int i=0;i&lt;n;++i) &#123; while (!st1.empty() &amp;&amp; A[st1.top()] &gt;= A[i]) &#123; right[st1.top()] = i; st1.pop(); &#125; st1.push(i); &#125; for (int i=n-1;i&gt;=0;--i) &#123; while (!st2.empty() &amp;&amp; A[st2.top()] &gt; A[i]) &#123; left[st2.top()] = i; st2.pop(); &#125; st2.push(i); &#125; int ans = 0; for (int i=0;i&lt;n;++i) &#123; ans += (left[i] - i) * (i-right[i]) * A[i]; ans %= 1000000007; &#125; return ans; &#125;&#125;; 时间和空间复杂度为O(n)。 接下来是单调队列的做法。单调队列是我最先想到的方法，但是初始版本的最坏复杂度过高，因此先放下来了。基本思路是这样的，比如说3 1 2 4，从左往右扫的过程中，先碰到3，3自然可以作为一个子数组，得到3，而继续扫的过程中，遇到了1，那么从3开始的数组，若碰到了1，那么接下来的最小值就是1了，另外，从1开始的数组，其子数组的最小值自然也是1，会得到队列1 1，接下来碰到了2，因为2比1小，所以2要作为最小值，只能重新开始作为新的子数组，而1可以继续延续作为子数组，得到队列1 1 2，到了4，队列就变成了1 1 3 4，最终结果就是每一个队列的和的和，这个和可以通过每一次的维护队列过程来进行维护。代码如下： AC代码： 123456789101112131415161718192021222324class Solution &#123;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; vector&lt;int&gt; que; int n = A.size(), sum = A[0]; que.push_back(A[0]); int cnt = 1, cur = A[0]; for (int i=1;i&lt;n;++i) &#123; int j = cnt - 1; while (j &gt;= 0 &amp;&amp; que[j] &gt; A[i]) &#123; cur = cur - que[j] + A[i]; que[j] = A[i]; j--; &#125; cnt++; cur += A[i]; que.push_back(A[i]); sum += cur; cur %= 1000000007; sum %= 1000000007; &#125; return sum; &#125;&#125;; 当然这个算法的最坏复杂度是O(n^2)，自然是不够看的。 实际上，可以发现队列是有序的，因此维护序列的过程中，可以通过二分查找来进行优化，优化之后结果的AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;private: int upperb(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;que, int size, int target) &#123; int left = 0; while (size &gt; 0) &#123; int half = size&gt;&gt;1; int mid = left+half; int idx = que[mid]; if (A[idx] &lt;= target) &#123; left = mid+1; size = size - half - 1; &#125; else &#123; size = half; &#125; &#125; return left; &#125;public: int sumSubarrayMins(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); vector&lt;int&gt; que(n), cursum(n); que[0] = 0; cursum[0] = A[0]; int cur = 1, sum = A[0]; for (int i=1;i&lt;n;++i) &#123; int p = upperb(A, que, cur, A[i]); if (p == 0) &#123; cursum[0] = A[i]*(i+1); que[0] = i; cur = 1; &#125; else &#123; cursum[p] = cursum[p-1] + A[i]*(i-que[p-1]); que[p] = i; cur = p+1; &#125; sum += cursum[cur-1]; cursum[cur-1] %= 1000000007; sum %= 1000000007; &#125; return sum; &#125;&#125;; 最坏复杂度是O(nlogn)，不过这是一个比较松的上界，实际表现比上面的单调栈代码快一丢丢。 补充一个二分查找的写法，这里二分查找优化是需要自己写，而不能单纯使用upper_bound这些的，我个人比较喜欢的写法是stl标准库的写法，有个first，size，二分过程中用half，可以自己去查阅文档啦~","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]}]}